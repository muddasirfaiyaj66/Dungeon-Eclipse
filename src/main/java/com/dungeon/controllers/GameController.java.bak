package com.dungeon.controllers;

import com.dungeon.effects.EffectsManager;
import com.dungeon.model.DungeonGenerator;
import com.dungeon.model.DungeonRoom;
import com.dungeon.model.entity.Enemy;
import com.dungeon.model.entity.EnemyAbility;
import com.dungeon.model.entity.Entity;
import com.dungeon.model.Door; 
import com.dungeon.model.Inventory;
import com.dungeon.model.Item;
import com.dungeon.model.entity.Player;
import com.dungeon.model.entity.Projectile;
import com.dungeon.model.entity.ProjectileAttack;
import com.dungeon.model.Puzzle;
import com.dungeon.view.DungeonRenderer;
import com.dungeon.view.LightingEffect;
import javafx.animation.AnimationTimer;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Point2D;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.KeyCode;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle; 
import javafx.stage.Modality;
import javafx.stage.Stage;
import javafx.util.Duration;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.HashMap;

public class GameController {
    // Enum for door directions
    public enum Direction {
        NORTH,
        SOUTH,
        EAST,
        WEST
    }

    @FXML
    private Canvas gameCanvas;
    @FXML
    private javafx.scene.layout.BorderPane rootPane;
    @FXML
    private javafx.scene.layout.StackPane canvasContainer;
    
    private DungeonGenerator dungeonGenerator;
    private DungeonRenderer dungeonRenderer;
    private List<DungeonRoom> currentDungeon;
    private Player player;
    private List<Enemy> enemies;
    private Set<KeyCode> activeKeys;
    private boolean gameLoopRunning;
    private boolean roomTransitionInProgress;
    private double mouseX, mouseY;
    private Random random;
    private EffectsManager effectsManager;
    private LightingEffect lightingEffect;
    private List<String> floatingTexts; // For displaying damage, pickups, etc.
    private List<ProjectileAttack> playerProjectiles;
    private List<EnemyAbility.Projectile> enemyProjectiles;
    private List<Item> roomItems; // Items in the current room
    private java.util.Map<DungeonRoom, Puzzle> puzzles; // Puzzles for puzzle rooms
    private List<Door> doors; // Doors in the current room
    private double timeSinceLastSpawn;
    private boolean bossDefeated;
    private boolean roomCleared;
    private DungeonRoom currentRoom;
    private long lastUpdateTime;
    private List<Projectile> projectiles = new ArrayList<>();
    private boolean puzzleCompleted;
    private int currentLevel = 1;
    private int enemiesDefeated = 0;
    private long startTime;
    private boolean gameOver = false;
    private boolean victory = false;
    private boolean isDebugMode = true; // Enable debug mode by default to diagnose issues

    // Room transition constants
    private static final double DOOR_WIDTH = 40;
    private static final double DOOR_HEIGHT = 40;
    private static final double ROOM_PADDING = 50; // Distance from room edge to door
    private static final double TRANSITION_DURATION = 0.5; // seconds

    private javafx.scene.layout.Pane minimapPane;
    private javafx.util.Map<DungeonRoom, Rectangle> minimapCells;

    // Game state
    private boolean isPaused = false;
    private javafx.scene.layout.VBox pauseMenu;
    
    // Menu components
    private javafx.scene.control.MenuBar menuBar;
    
    // Add resize handling
    private void handleResize() {
        if (canvasContainer == null || gameCanvas == null) {
            System.err.println("WARNING: canvasContainer or gameCanvas is null in handleResize");
            return;
        }
        
        System.out.println("Setting up window resize handling...");
        
        // Bind canvas size to parent container size
        gameCanvas.widthProperty().bind(canvasContainer.widthProperty());
        gameCanvas.heightProperty().bind(canvasContainer.heightProperty());
        
        // Add listener for canvas width changes
        gameCanvas.widthProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            
            System.out.println("Canvas width changed: " + oldVal + " -> " + newVal);
            
            // Force rendering if player exists and game is not paused
            if (player != null && !isPaused) {
                // Keep player in the bounds of the new canvas
                double playerX = player.getX();
                if (playerX > newVal.doubleValue() - player.getWidth()) {
                    player.setPosition(newVal.doubleValue() - player.getWidth(), player.getY());
                }
                
                // Render the updated scene
                render();
            }
        });
        
        // Add listener for canvas height changes
        gameCanvas.heightProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            
            System.out.println("Canvas height changed: " + oldVal + " -> " + newVal);
            
            // Force rendering if player exists and game is not paused
            if (player != null && !isPaused) {
                // Keep player in the bounds of the new canvas
                double playerY = player.getY();
                if (playerY > newVal.doubleValue() - player.getHeight()) {
                    player.setPosition(player.getX(), newVal.doubleValue() - player.getHeight());
                }
                
                // Render the updated scene
                render();
            }
        });
        
        // Also bind the root pane to the scene size
        if (rootPane != null && rootPane.getScene() != null) {
            rootPane.prefWidthProperty().bind(rootPane.getScene().widthProperty());
            rootPane.prefHeightProperty().bind(rootPane.getScene().heightProperty());
        }
        
        System.out.println("Window resize handling set up successfully");
    }
    
    private void createPauseMenu() {
        pauseMenu = new javafx.scene.layout.VBox(10);
        pauseMenu.setAlignment(javafx.geometry.Pos.CENTER);
        pauseMenu.setStyle("-fx-background-color: rgba(0, 0, 0, 0.7); -fx-padding: 20px;");
        pauseMenu.setPrefWidth(300);
        pauseMenu.setPrefHeight(200);
        
        // Create title
        javafx.scene.text.Text title = new javafx.scene.text.Text("Paused");
        title.setFont(javafx.scene.text.Font.font("Verdana", javafx.scene.text.FontWeight.BOLD, 24));
        title.setFill(javafx.scene.paint.Color.WHITE);
        
        // Create buttons
        javafx.scene.control.Button resumeButton = new javafx.scene.control.Button("Resume Game");
        resumeButton.setPrefWidth(200);
        resumeButton.setOnAction(e -> resumeGame());
        
        javafx.scene.control.Button optionsButton = new javafx.scene.control.Button("Options");
        optionsButton.setPrefWidth(200);
        optionsButton.setOnAction(e -> showOptions());
        
        javafx.scene.control.Button exitButton = new javafx.scene.control.Button("Exit to Main Menu");
        exitButton.setPrefWidth(200);
        exitButton.setOnAction(e -> exitToMainMenu());
        
        // Add components to menu
        pauseMenu.getChildren().addAll(title, resumeButton, optionsButton, exitButton);
        
        // Center the pause menu
        javafx.scene.layout.StackPane.setAlignment(pauseMenu, javafx.geometry.Pos.CENTER);
        
        // Initially hide the pause menu
        pauseMenu.setVisible(false);
        
        // Add to root pane
        rootPane.getChildren().add(pauseMenu);
    }
    
    private void togglePauseGame() {
        isPaused = !isPaused;
        
        if (isPaused) {
            pauseMenu.setVisible(true);
            // Stop the game loop
            gameLoopRunning = false;
            
            System.out.println("Game paused");
        } else {
            pauseMenu.setVisible(false);
            // Resume the game loop
            gameLoopRunning = true;
            startGameLoop();
            
            // Make sure canvas has focus
            gameCanvas.requestFocus();
            
            System.out.println("Game resumed");
        }
    }
    
    private void resumeGame() {
        isPaused = false;
        pauseMenu.setVisible(false);
        gameLoopRunning = true;
        startGameLoop();
        
        // Make sure canvas has focus
        gameCanvas.requestFocus();
    }
    
    private void showOptions() {
        // In a full implementation, you would show options dialog
        // For now, just show a message
        System.out.println("Options would be shown here");
    }
    
    private void exitToMainMenu() {
        try {
            // Load the main menu
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/MainMenu.fxml"));
            Parent menuRoot = loader.load();
            Scene menuScene = new Scene(menuRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(menuScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    public void initialize() {
        dungeonGenerator = new DungeonGenerator();
        dungeonRenderer = new DungeonRenderer(gameCanvas);
        activeKeys = new HashSet<>();
        enemies = new ArrayList<>();
        roomItems = new ArrayList<>();
        puzzles = new java.util.HashMap<>();
        doors = new ArrayList<>();
        playerProjectiles = new ArrayList<>();
        enemyProjectiles = new ArrayList<>();
        effectsManager = new EffectsManager(rootPane, gameCanvas);
        floatingTexts = new ArrayList<>();
        random = new Random();
        timeSinceLastSpawn = 0;
        bossDefeated = false;
        gameLoopRunning = true;
        roomTransitionInProgress = false;
        roomCleared = false;
        puzzleCompleted = false;
        
        // Set the start time when game begins
        startTime = System.currentTimeMillis();
        
        // Create the pause menu
        createPauseMenu();
        
        setupGame();
        startGameLoop();
    }

    public void onSceneReady() {
        // Setup input handling
        setupInputHandling();
        
        // Initialize lighting effect after canvas is attached to scene
        lightingEffect = new LightingEffect(gameCanvas);
        
        // Setup window resize handling
        handleResize();
        
        // Create menu bar
        createMenuBar();
        
        // Request focus on the canvas so it can receive key events
        gameCanvas.setFocusTraversable(true);
        gameCanvas.requestFocus();
    }

    private void setupGame() {
        // Initialize game components
        random = new Random();
        activeKeys = new HashSet<>();
        enemies = new ArrayList<>();
        roomItems = new ArrayList<>();
        doors = new ArrayList<>();
        playerProjectiles = new ArrayList<>();
        projectiles = new ArrayList<>();
        
        // Initialize effects manager if not already initialized
        if (effectsManager == null) {
            effectsManager = new EffectsManager(rootPane, gameCanvas);
        }
        
        // Set gameLoopRunning flag
        gameLoopRunning = true;
        
        // Generate dungeon
        System.out.println("Generating dungeon...");
        dungeonGenerator = new DungeonGenerator();
        currentDungeon = dungeonGenerator.generateDungeon();
        
        System.out.println("Dungeon created with " + currentDungeon.size() + " rooms");
        
        // Set current room to spawn room
        java.util.Optional<DungeonRoom> spawnRoom = currentDungeon.stream()
            .filter(room -> room.getType() == DungeonRoom.RoomType.SPAWN)
            .findFirst();
            
        if (spawnRoom.isPresent()) {
            currentRoom = spawnRoom.get();
            currentRoom.setVisited(true);
            
            System.out.println("Found spawn room: " + currentRoom);
            
            // Generate puzzles for puzzle rooms
            generatePuzzles();
            
            // Find spawn room and place player
            Point2D spawnPoint = new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 2);
            player = new Player(spawnPoint.getX(), spawnPoint.getY());
            
            System.out.println("Player created at " + spawnPoint);
            
            populateRoom(currentRoom);
            createDoors();
        } else {
            System.err.println("ERROR: No spawn room found in dungeon!");
        }
    }

    private void generatePuzzles() {
        for (DungeonRoom room : currentDungeon) {
            if (room.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Create a random puzzle for each puzzle room
                puzzles.put(room, Puzzle.createRandomPuzzle());
            }
        }
    }

    private void setupInputHandling() {
        if (gameCanvas == null) {
            System.err.println("ERROR: gameCanvas is null in setupInputHandling");
            return;
        }
        
        // Handle keyboard input
        gameCanvas.setOnKeyPressed(e -> {
            // Add key to active keys
            activeKeys.add(e.getCode());
            
            // Special key handlers
            switch (e.getCode()) {
                case ESCAPE:
                    // Toggle pause menu
                    togglePauseGame();
                    break;
                    
                case I:
                    // Open inventory
                    if (!isPaused) {
                        openInventory();
                    }
                    break;
                    
                case F:
                    // Use health potion
                    if (player.getInventory().hasItem(Item.ItemType.POTION)) {
                        Item potion = player.getInventory().getItems().stream()
                            .filter(item -> item.getType() == Item.ItemType.POTION)
                            .findFirst().orElse(null);
                        
                        if (potion != null) {
                            player.useItem(potion);
                            effectsManager.showFloatingText("Used healing potion!", 
                                player.getPosition().add(0, -20), Color.GREEN);
                        }
                    } else {
                        effectsManager.showFloatingText("No healing potions!", 
                            player.getPosition().add(0, -20), Color.RED);
                    }
                    break;
                    
                case E:
                    // Interact with objects
                    handleDoorInteraction();
                    
                    // Interact with puzzle or door
                    if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE && !puzzles.get(currentRoom).isSolved()) {
                        interactWithPuzzle();
                    }
                    break;
                    
                case DIGIT1:
                    // Select weapon 1 (Sword)
                    selectWeapon(0);
                    break;
                    
                case DIGIT2:
                    // Select weapon 2 (Bow)
                    selectWeapon(1);
                    break;
                    
                case DIGIT3:
                    // Select weapon 3 (Staff)
                    selectWeapon(2);
                    break;
                    
                case DIGIT4:
                    // Select weapon 4 (Axe)
                    selectWeapon(3);
                    break;
                    
                case SPACE:
                    // Melee attack
                    attackEnemiesInRange();
                    break;
                    
                case M:
                    // Toggle debug mode
                    isDebugMode = !isDebugMode;
                    System.out.println("Debug mode: " + isDebugMode);
                    break;
                    
                default:
                    // Other keys handled by active keys set
                    break;
            }
        });
        
        gameCanvas.setOnKeyReleased(e -> {
            // Remove key from active keys
            activeKeys.remove(e.getCode());
        });
        
        // Handle mouse input
        gameCanvas.setOnMouseMoved(e -> {
            mouseX = e.getX();
            mouseY = e.getY();
            
            // Update player aim direction
            if (player != null) {
                player.updateMousePosition(mouseX, mouseY);
            }
        });
        
        gameCanvas.setOnMouseClicked(e -> {
            switch (e.getButton()) {
                case PRIMARY:
                    // Left click - fire projectile
                    firePlayerProjectile();
                    break;
                    
                case SECONDARY:
                    // Right click - activate special ability (not implemented yet)
                    break;
                    
                default:
                    // Other mouse buttons not used
                    break;
            }
        });
        
        // Make sure the canvas can receive key events
        gameCanvas.setFocusTraversable(true);
    }

    private void attackEnemiesInRange() {
        // Find enemies in melee range and damage them
        double meleeRange = 50; // Melee attack range
        for (Enemy enemy : enemies) {
            if (isInMeleeRange(player, enemy)) {
                // Apply melee damage
                double meleeDamage = 20;
                enemy.takeDamage(meleeDamage);
                
                // Show damage text
                effectsManager.showFloatingText("-" + (int)meleeDamage, 
                    enemy.getPosition(), Color.ORANGE);
            }
        }
    }

    private void startGameLoop() {
        // Don't create a new AnimationTimer if we already have one running
        if (gameLoopRunning) {
            lastUpdateTime = System.nanoTime();
            
            AnimationTimer timer = new AnimationTimer() {
                @Override
                public void handle(long now) {
                    if (gameLoopRunning && !roomTransitionInProgress && !isPaused) {
                        double deltaTime = (now - lastUpdateTime) / 1_000_000_000.0;
                        lastUpdateTime = now;
                        
                        update(deltaTime);
                        render();
                    }
                }
            };
            
            timer.start();
        }
    }

    private void update(double deltaTime) {
        // Debug game state
        System.out.println("UPDATE CALLED | gameLoopRunning=" + gameLoopRunning + 
                          " | roomTransitionInProgress=" + roomTransitionInProgress);
                          
        // Check if player is initialized
        if (player == null) {
            System.out.println("ERROR: Player is null in update method");
            setupGame(); // Try to re-initialize the game
            return;
        }
        
        // Check if current room is initialized
        if (currentRoom == null) {
            System.out.println("ERROR: Current room is null in update method");
            setupGame(); // Try to re-initialize the game
            return;
        }
        
        // Skip update if room transition is in progress
        if (roomTransitionInProgress) {
            return;
        }
        
        // Debug message for room type
        String roomType = currentRoom.getType().toString();
        System.out.println("Current room type: " + roomType + " | Enemies: " + enemies.size() + " | Items: " + roomItems.size() + " | Projectiles: " + playerProjectiles.size());
        
        // Handle player input
        player.handleInput(activeKeys, deltaTime);
        
        // Move player
        movePlayer(deltaTime);
        
        // Check for item pickups
        checkItemPickups();
        
        // Check for door interactions
        checkDoorInteraction();
        
        // Check for room transitions
        checkRoomTransition();
        
        // Update enemies
        updateEnemies(deltaTime);
        
        // Update projectiles
        updateProjectiles(deltaTime);
        
        // Update player projectiles
        updatePlayerProjectiles(deltaTime);
        
        // Check for enemy defeat conditions
        checkRoomClearConditions();
        
        // Check player status
        checkPlayerStatus();
        
        // Check victory condition
        checkVictoryCondition();
        
        // Update effects
        effectsManager.update(deltaTime);
    }
    
    private void checkItemPickups() {
        Iterator<Item> itemIterator = roomItems.iterator();
        while (itemIterator.hasNext()) {
            Item item = itemIterator.next();
            
            // Debug print
            System.out.println("Checking item: " + item.getName() + " at " + item.getX() + "," + item.getY());
            System.out.println("Player position: " + player.getX() + "," + player.getY());

            // Improved collision detection for items
            Point2D playerCenter = player.getPosition().add(player.getSize() / 2, player.getSize() / 2);
            Point2D itemCenter = new Point2D(item.getX(), item.getY());
            double distance = playerCenter.distance(itemCenter);

            // If player is close enough to item
            if (distance < (player.getSize() / 2 + item.getSize() / 2)) {
                System.out.println("Player picked up: " + item.getName());
                
                // Handle item pickup based on type
                switch (item.getType()) {
                    case POTION:
                        player.heal(20); // Heal player by 20 HP
                        effectsManager.showFloatingText("+" + 20 + " HP", 
                            player.getPosition(), Color.GREEN);
                        player.addScore(25); // Add score for potion
                        break;
                    case WEAPON:
                        // Add weapon to inventory
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.YELLOW);
                        player.addScore(50); // Add score for weapon
                        break;
                    case ARMOR:
                        // Add armor to inventory
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.BLUE);
                        player.addScore(50); // Add score for armor
                        break;
                    case KEY:
                        // Unlock all doors in the current room
                        unlockDoorsWithKey();
                        effectsManager.showFloatingText("Doors unlocked!", 
                            player.getPosition(), Color.GOLD);
                        player.addScore(100); // Add score for key
                        break;
                    default:
                        // Generic pickup
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.WHITE);
                        player.addScore(25); // Default score addition
                        break;
                }
                
                // Remove item from room
                itemIterator.remove();
            }
        }
    }
    
    private void unlockDoorsWithKey() {
        for (Door door : doors) {
            if (door.requiresKey()) {
                door.unlockWithKey();
            }
        }
    }
    
    private void checkDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item name for debug or when player is close
            if (isDebugMode || (player != null && 
                player.getPosition().distance(new Point2D(item.getX(), item.getY())) < 100)) {
                gc.setFill(Color.WHITE);
                gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                gc.fillText(item.getName(), item.getX() - 20, item.getY() - 10);
            }
        }
        
        // Draw enemies
        if (enemies.isEmpty()) {
            System.out.println("No enemies to render in current room");
        } else {
            System.out.println("Rendering " + enemies.size() + " enemies");
            for (Enemy enemy : enemies) {
                System.out.println("Rendering enemy at: " + enemy.getX() + "," + enemy.getY() + " of type: " + enemy.getType());
                // Draw enemy as a red rectangle
                if (enemy.getType() == Enemy.EnemyType.BOSS) {
                    gc.setFill(Color.DARKRED);
                    // Draw boss larger
                    gc.fillRect(enemy.getX() - 5, enemy.getY() - 5, enemy.getSize() + 10, enemy.getSize() + 10);
                } else {
                    gc.setFill(Color.RED);
                    gc.fillRect(enemy.getX(), enemy.getY(), enemy.getSize(), enemy.getSize());
                }
                
                // Draw enemy health bar
                double healthPercentage = (double) enemy.getHealth() / enemy.getMaxHealth();
                double healthBarWidth = enemy.getSize() * healthPercentage;
                
                gc.setFill(Color.BLACK);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, enemy.getSize(), 5);
                gc.setFill(Color.GREEN);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, healthBarWidth, 5);
                
                // Draw enemy type if debug mode is on
                if (isDebugMode) {
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(enemy.getType().toString(), enemy.getX(), enemy.getY() - 12);
                }
            }
        }
        
        // Draw player projectiles
        for (ProjectileAttack attack : playerProjectiles) {
            attack.render(gc);
        }
        
        // Draw projectiles
        for (Projectile projectile : projectiles) {
            projectile.render(gc);
        }
        
        // Draw the player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw UI elements
        renderUI(gc);
    }
    
    private void drawPauseButton(GraphicsContext gc) {
        // Draw pause button in top-right corner
        double buttonSize = 30;
        double padding = 10;
        double x = gameCanvas.getWidth() - buttonSize - padding;
        double y = padding;
        
        // Draw button background
        gc.setFill(Color.DARKGRAY);
        gc.fillRoundRect(x, y, buttonSize, buttonSize, 5, 5);
        
        // Draw pause icon
        gc.setFill(Color.WHITE);
        gc.fillRect(x + buttonSize * 0.3, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        gc.fillRect(x + buttonSize * 0.55, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        
        // Draw button border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(x, y, buttonSize, buttonSize, 5, 5);
    }
    
    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            gc.setFill(Color.BLACK);
            gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
            return;
        }
        
        System.out.println("Drawing background for room type: " + currentRoom.getType());
        
        // Set the base background color based on room type
        Color baseColor;
        switch (currentRoom.getType()) {
            case SPAWN:
                baseColor = Color.rgb(0, 80, 0); // Dark green for spawn
                break;
            case COMBAT:
                baseColor = Color.rgb(70, 30, 30); // Dark red for combat
                break;
            case PUZZLE:
                baseColor = Color.rgb(30, 30, 80); // Dark blue for puzzle
                break;
            case TREASURE:
                baseColor = Color.rgb(80, 80, 30); // Gold for treasure
                break;
            case BOSS:
                baseColor = Color.rgb(80, 0, 0); // Deep red for boss
                break;
            default:
                baseColor = Color.rgb(30, 30, 30); // Dark gray default
                break;
        }
        
        // Fill the entire canvas with the base color
        gc.setFill(baseColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw floor tiles based on room type
        double tileSize = 40;
        
        switch (currentRoom.getType()) {
            case COMBAT:
                drawCombatRoomFloor(gc, tileSize);
                break;
            case PUZZLE:
                drawPuzzleRoomFloor(gc, tileSize);
                break;
            case TREASURE:
                drawTreasureRoomFloor(gc, tileSize);
                break;
            case BOSS:
                drawBossRoomFloor(gc, tileSize);
                break;
            case SPAWN:
            default:
                drawSpawnRoomFloor(gc, tileSize);
                break;
        }
        
        // Draw room borders
        gc.setStroke(Color.DARKGRAY);
        gc.setLineWidth(5);
        gc.strokeRect(10, 10, gameCanvas.getWidth() - 20, gameCanvas.getHeight() - 20);
    }
    
    private void drawCombatRoomFloor(GraphicsContext gc, double tileSize) {
        // Checkered pattern in dark red
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(60, 20, 20));
                } else {
                    gc.setFill(Color.rgb(40, 10, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add some blood stains
        gc.setFill(Color.rgb(120, 0, 0, 0.3));
        for (int i = 0; i < 10; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 20 + random.nextDouble() * 30;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawPuzzleRoomFloor(GraphicsContext gc, double tileSize) {
        // Blue tiled pattern with symbols
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(20, 30, 50));
                gc.fillRect(x, y, tileSize, tileSize);
                
                // Add tile borders
                gc.setStroke(Color.rgb(30, 40, 70));
                gc.strokeRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add arcane symbols
        gc.setFill(Color.rgb(100, 150, 255, 0.2));
        for (int i = 0; i < 8; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 30 + random.nextDouble() * 40;
            
            // Draw a random arcane symbol (simplified)
            double angle = random.nextDouble() * Math.PI * 2;
            double[] xPoints = new double[5];
            double[] yPoints = new double[5];
            
            for (int j = 0; j < 5; j++) {
                xPoints[j] = x + Math.cos(angle + j * Math.PI * 2 / 5) * size / 2;
                yPoints[j] = y + Math.sin(angle + j * Math.PI * 2 / 5) * size / 2;
            }
            
            gc.fillPolygon(xPoints, yPoints, 5);
        }
    }
    
    private void drawTreasureRoomFloor(GraphicsContext gc, double tileSize) {
        // Gold/yellow tiled pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(80, 70, 20));
                } else {
                    gc.setFill(Color.rgb(60, 50, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add gold coins scattered around
        gc.setFill(Color.GOLD);
        for (int i = 0; i < 30; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 3 + random.nextDouble() * 5;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawBossRoomFloor(GraphicsContext gc, double tileSize) {
        // Dark pattern with lava cracks
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(30, 10, 10));
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add lava cracks
        gc.setFill(Color.rgb(255, 50, 0, 0.7));
        for (int i = 0; i < 15; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double width = 5 + random.nextDouble() * 100;
            double height = 3 + random.nextDouble() * 5;
            double angle = random.nextDouble() * Math.PI;
            
            gc.save();
            gc.translate(x, y);
            gc.rotate(Math.toDegrees(angle));
            gc.fillRect(-width/2, -height/2, width, height);
            gc.restore();
        }
    }
    
    private void drawSpawnRoomFloor(GraphicsContext gc, double tileSize) {
        // Green/brown natural pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(30, 50, 30));
                } else {
                    gc.setFill(Color.rgb(40, 60, 40));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
    }
    
    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Clear previous lights
        lightingEffect.clearLights();
        
        // Set ambient light based on room type
        switch (currentRoom.getType()) {
            case COMBAT:
                lightingEffect.setAmbientLight(0.3); // Dim red lighting
                break;
                
            case PUZZLE:
                lightingEffect.setAmbientLight(0.4); // Moderate blue lighting
                break;
                
            case TREASURE:
                lightingEffect.setAmbientLight(0.5); // Brighter gold lighting
                break;
                
            case BOSS:
                lightingEffect.setAmbientLight(0.2); // Very dark with red tint
                break;
                
            case SPAWN:
            default:
                lightingEffect.setAmbientLight(0.6); // Bright natural lighting
                break;
        }
        
        // Add player light
        lightingEffect.addLightSource(
            player.getPosition(), 
            150, 
            Color.WHITE, 
            LightingEffect.LightSource.LightType.FLICKERING
        );
        
        // Add door lights
        for (Door door : doors) {
            Color lightColor = door.isLocked() ? Color.RED : Color.GREEN;
            lightingEffect.addLightSource(
                new Point2D(door.getX() + door.getWidth()/2, door.getY() + door.getHeight()/2),
                60,
                lightColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add item lights
        for (Item item : roomItems) {
            Color itemColor = getItemColor(item.getType());
            lightingEffect.addLightSource(
                new Point2D(item.getX(), item.getY()),
                item.getSize() * 3,
                itemColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add enemy lights
        for (Enemy enemy : enemies) {
            Color enemyColor = Color.RED;
            if (enemy.getType() == Enemy.EnemyType.BOSS) {
                enemyColor = Color.DARKRED;
            } else if (enemy.getType() == Enemy.EnemyType.MAGE) {
                enemyColor = Color.BLUE;
            }
            
            lightingEffect.addLightSource(
                enemy.getPosition(),
                enemy.getSize() * 2,
                enemyColor,
                enemy.getType() == Enemy.EnemyType.BOSS ? 
                    LightingEffect.LightSource.LightType.PULSING : 
                    LightingEffect.LightSource.LightType.FLICKERING
            );
        }
        
        // Add environmental lights based on room type
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
            // Add lava lights for boss room
            for (int i = 0; i < 5; i++) {
                double x = random.nextDouble() * gameCanvas.getWidth();
                double y = random.nextDouble() * gameCanvas.getHeight();
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    30 + random.nextDouble() * 50,
                    Color.ORANGE,
                    LightingEffect.LightSource.LightType.FLICKERING
                );
            }
        } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            // Add arcane lights for puzzle room
            for (int i = 0; i < 4; i++) {
                double x = 100 + i * (gameCanvas.getWidth() - 200) / 3;
                double y = gameCanvas.getHeight() / 2;
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    70,
                    Color.CYAN,
                    LightingEffect.LightSource.LightType.PULSING
                );
            }
        }
    }
    
    private void renderUI(GraphicsContext gc) {
        if (player == null) return;
        
        // Set up fonts
        Font titleFont = Font.font("Arial", FontWeight.BOLD, 16);
        Font normalFont = Font.font("Arial", FontWeight.NORMAL, 14);
        
        // Draw player health bar
        double healthBarWidth = 200;
        double healthBarHeight = 20;
        double healthPercentage = (double) player.getHealth() / player.getMaxHealth();
        
        // Health bar background
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health bar fill
        Color healthColor;
        if (healthPercentage > 0.7) {
            healthColor = Color.GREEN;
        } else if (healthPercentage > 0.3) {
            healthColor = Color.YELLOW;
        } else {
            healthColor = Color.RED;
        }
        
        gc.setFill(healthColor);
        gc.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
        
        // Health bar border
        gc.setStroke(Color.BLACK);
        gc.setLineWidth(2);
        gc.strokeRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health text
        gc.setFill(Color.WHITE);
        gc.setFont(normalFont);
        gc.fillText("HP: " + (int)player.getHealth() + "/" + (int)player.getMaxHealth(), 
                    25, 36);
        
        // Draw current weapon info
        String weaponText = "Weapon: " + player.getCurrentWeapon().getType().getName();
        gc.fillText(weaponText, 20, 60);
        
        // Draw score
        gc.setFont(normalFont);
        gc.fillText("Score: " + player.getScore(), 20, 80);
        
        // Draw enemy count
        gc.fillText("Enemies: " + enemies.size(), 20, 100);
        
        // Draw level info
        gc.fillText("Level: " + currentLevel, 20, 120);
        
        // Draw current room type
        String roomTypeText = "Room: " + (currentRoom != null ? currentRoom.getType().toString() : "UNKNOWN");
        gc.fillText(roomTypeText, 20, 140);
        
        // Draw mini-map in top-right corner if needed
        if (isDebugMode) {
            drawMiniMap(gc);
        }
        
        // Draw FPS counter in debug mode
        if (isDebugMode) {
            long currentTime = System.nanoTime();
            double fps = 1_000_000_000.0 / (currentTime - lastUpdateTime);
            gc.fillText(String.format("FPS: %.1f", fps), gameCanvas.getWidth() - 100, 20);
        }
        
        // Controls reminder at the bottom
        gc.setFill(Color.LIGHTBLUE);
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                   gameCanvas.getWidth() / 2 - 200, gameCanvas.getHeight() - 20);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        double cellSize = 10;
        
        // Draw mini-map background
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw mini-map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Find min/max coordinates to center the map
        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
        
        for (DungeonRoom room : currentDungeon) {
            minX = Math.min(minX, room.getX());
            minY = Math.min(minY, room.getY());
            maxX = Math.max(maxX, room.getX());
            maxY = Math.max(maxY, room.getY());
        }
        
        // Calculate scaling to fit all rooms
        int mapWidth = maxX - minX + 1;
        int mapHeight = maxY - minY + 1;
        double scaleX = mapSize / (mapWidth * 1.5);
        double scaleY = mapSize / (mapHeight * 1.5);
        double scale = Math.min(scaleX, scaleY);
        
        // Calculate offset to center the map
        double offsetX = mapX + (mapSize - mapWidth * scale) / 2;
        double offsetY = mapY + (mapSize - mapHeight * scale) / 2;
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = offsetX + (room.getX() - minX) * scale;
            double roomY = offsetY + (room.getY() - minY) * scale;
            
            // Choose color based on room type
            Color roomColor;
            switch (room.getType()) {
                case SPAWN:
                    roomColor = Color.GREEN;
                    break;
                case BOSS:
                    roomColor = Color.RED;
                    break;
                case PUZZLE:
                    roomColor = Color.BLUE;
                    break;
                case TREASURE:
                    roomColor = Color.GOLD;
                    break;
                default:
                    roomColor = Color.GRAY;
            }
            
            // Draw room
            gc.setFill(room.isVisited() ? roomColor : Color.DARKGRAY);
            gc.fillRect(roomX, roomY, scale * 0.8, scale * 0.8);
            
            // If this is the current room, highlight it
            if (room == currentRoom) {
                gc.setStroke(Color.WHITE);
                gc.setLineWidth(2);
                gc.strokeRect(roomX, roomY, scale * 0.8, scale * 0.8);
            }
        }
        
        // Draw minimap legend
        double legendX = mapX + 10;
        double legendY = mapY + mapSize + 10;
        double legendBoxSize = 8;
        double textOffset = 15;
        
        gc.setFont(Font.font("Arial", FontWeight.NORMAL, 10));
        
        // Current room
        gc.setFill(Color.WHITE);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.fillText("Current", legendX + legendBoxSize + 5, legendY + 8);
        
        // Spawn room
        legendY += textOffset;
        gc.setFill(Color.GREEN);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Spawn", legendX + legendBoxSize + 5, legendY + 8);
        
        // Boss room
        legendY += textOffset;
        gc.setFill(Color.RED);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Boss", legendX + legendBoxSize + 5, legendY + 8);
        
        // Unvisited room
        legendY += textOffset;
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Unexplored", legendX + legendBoxSize + 5, legendY + 8);
    }

    public Player getPlayer() {
        return player;
    }

    private Color getItemColor(Item.ItemType type) {
        switch (type) {
            case WEAPON: return Color.RED;
            case POTION: return Color.GREEN;
            case ARMOR: return Color.BLUE;
            default: return Color.WHITE;
        }
    }

    private void createDoors() {
        // First remove existing doors
        doors.clear();
        
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors for null room");
            return;
        }
        
        System.out.println("Creating doors for room " + currentRoom.getType() + 
                          " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")");
        
        List<DungeonRoom> connectedRooms = currentRoom.getConnectedRooms();
        System.out.println("Connected rooms: " + connectedRooms.size());
        
        if (connectedRooms.isEmpty()) {
            System.err.println("WARNING: Room has no connected rooms!");
            return;
        }
        
        // Determine room bounds on the canvas
        double roomWidth = gameCanvas.getWidth() - 100;  // 50px margin on each side
        double roomHeight = gameCanvas.getHeight() - 100;
        double doorWidth = DOOR_WIDTH;
        double doorHeight = DOOR_HEIGHT;
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : connectedRooms) {
            if (connectedRoom == null) {
                System.err.println("WARNING: Connected room is null!");
                continue;
            }
            
            // Determine direction to the connected room
            int dx = connectedRoom.getX() - currentRoom.getX();
            int dy = connectedRoom.getY() - currentRoom.getY();
            
            System.out.println("Adding door to " + connectedRoom.getType() + 
                              " at direction (" + dx + "," + dy + ")");
            
            // Calculate door position based on direction
            double doorX, doorY;
            Door.DoorDirection doorDirection;
            
            if (dx > 0) {      // East door
                doorX = roomWidth - doorWidth + 50;
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.EAST;
            } else if (dx < 0) { // West door
                doorX = 50;  // Left margin
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.WEST;
            } else if (dy > 0) { // South door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = roomHeight - doorHeight + 50;
                doorDirection = Door.DoorDirection.SOUTH;
            } else {            // North door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = 50;  // Top margin
                doorDirection = Door.DoorDirection.NORTH;
            }
            
            // Create the door
            Door door = new Door(
                doorX, doorY, doorWidth, doorHeight,
                currentRoom, connectedRoom, doorDirection
            );
            
            // Lock doors based on room type
            if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT ||
                currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                // Combat rooms: doors are locked until enemies are defeated
                door.setLocked(!enemies.isEmpty());
                System.out.println("Combat/Boss room door locked state: " + door.isLocked() + 
                                 " (enemies: " + enemies.size() + ")");
            } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Puzzle rooms: doors are locked until puzzle is solved
                door.setLocked(!puzzleCompleted);
                door.setRequiresKey(true);
                System.out.println("Puzzle room door locked state: " + door.isLocked() + 
                                 " (puzzle completed: " + puzzleCompleted + ")");
            }
            
            doors.add(door);
            System.out.println("Added door at " + doorX + "," + doorY + 
                              " to " + connectedRoom.getType() + 
                              " (locked: " + door.isLocked() + ", requires key: " + door.requiresKey() + ")");
        }
        
        // Debug output of created doors
        if (doors.isEmpty()) {
            System.err.println("WARNING: No doors were created!");
        } else {
            System.out.println("Created " + doors.size() + " doors");
        }
    }
    
    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        roomCleared = false;
        
        System.out.println("Populating room of type: " + room.getType() + " at position " + room.getX() + "," + room.getY());
        
        // Get room center
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        Point2D roomCenter = new Point2D(centerX, centerY);
        
        switch (room.getType()) {
            case COMBAT:
                // Add enemies in combat rooms
                spawnEnemiesForRoom(room, false);
                
                // Add a health potion
                if (new Random().nextDouble() < 0.5) {
                    spawnBasicItem(roomCenter.add(50, 50));
                    System.out.println("Added health potion to combat room");
                }
                break;
                
            case BOSS:
                // Add boss enemy with enhanced spawning
                spawnEnemiesForRoom(room, true);
                break;
                
            case TREASURE:
                // Add random items
                System.out.println("Spawning items in treasure room");
                Random rnd = new Random();
                int itemCount = 2 + rnd.nextInt(3); // 2-4 items
                
                for (int i = 0; i < itemCount; i++) {
                    double angle = rnd.nextDouble() * Math.PI * 2; // Random angle
                    double distance = 50 + rnd.nextDouble() * 100; // Distance from center
                    
                    double offsetX = Math.cos(angle) * distance;
                    double offsetY = Math.sin(angle) * distance;
                    
                    spawnBasicItem(roomCenter.add(offsetX, offsetY));
                }
                break;
                
            case PUZZLE:
                // Add a key
                System.out.println("Adding key to puzzle room");
                placeKeyInRoom(room);
                break;
                
            case SPAWN:
            default:
                // No special spawns in spawn room
                break;
        }
        
        // Create doors for the new room
        createDoors();
    }
    
    /**
     * Enhanced enemy spawning system for rooms
     */
    private void spawnEnemiesForRoom(DungeonRoom room, boolean isBossRoom) {
        Random random = new Random();
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        if (isBossRoom) {
            System.out.println("Spawning boss in boss room");
            // Create a boss enemy
            Enemy bossEnemy = new Enemy(centerX, centerY, Enemy.EnemyType.BOSS);
            
            // Double the boss's max health and increase damage
            bossEnemy.setMaxHealth(bossEnemy.getMaxHealth() * 2);
            bossEnemy.heal(bossEnemy.getMaxHealth()); // Heal to full health
            
            // Add the boss
            enemies.add(bossEnemy);
            
            // Add minions around the boss
            int minionCount = 1 + random.nextInt(2); // 1-2 minions
            for (int i = 0; i < minionCount; i++) {
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 120 + random.nextInt(50);
                
                double enemyX = centerX + Math.cos(angle) * distance;
                double enemyY = centerY + Math.sin(angle) * distance;
                
                // Keep within bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Create a minion (using the constructor with behavior parameter)
                Enemy minion = new Enemy(enemyX, enemyY, Enemy.EnemyType.SKELETON, Enemy.BehaviorType.AGGRESSIVE, 1);
                enemies.add(minion);
            }
            
            System.out.println("Spawned boss with " + minionCount + " minions");
        } else {
            // Regular combat room
            int playerLevel = player != null ? player.getLevel() : 1;
            int roomDepth = Math.abs(room.getX()) + Math.abs(room.getY());
            
            // Adjust enemy count based on player level and room distance from spawn
            int baseEnemyCount = 2;
            int levelBonus = (playerLevel - 1) / 2; // Every 2 levels adds an enemy
            int depthBonus = roomDepth / 3; // Every 3 rooms deeper adds an enemy
            int maxEnemyCount = Math.min(6, baseEnemyCount + levelBonus + depthBonus);
            int enemyCount = baseEnemyCount + random.nextInt(maxEnemyCount - baseEnemyCount + 1);
            
            System.out.println("Spawning " + enemyCount + " enemies in combat room (player level: " + 
                              playerLevel + ", room depth: " + roomDepth + ")");
            
            // Determine possible enemy types based on depth
            List<Enemy.EnemyType> possibleTypes = new ArrayList<>();
            possibleTypes.add(Enemy.EnemyType.GOBLIN);  // Always available
            
            if (roomDepth > 1 || playerLevel > 1) {
                possibleTypes.add(Enemy.EnemyType.SKELETON);
            }
            
            if (roomDepth > 3 || playerLevel > 3) {
                possibleTypes.add(Enemy.EnemyType.ORC);
            }
            
            if (roomDepth > 5 || playerLevel > 5) {
                possibleTypes.add(Enemy.EnemyType.MAGE);
            }
            
            // Spawn enemies
            for (int i = 0; i < enemyCount; i++) {
                // Calculate random position within the room, away from center
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 100 + random.nextDouble() * 150;
                
                double offsetX = Math.cos(angle) * distance;
                double offsetY = Math.sin(angle) * distance;
                
                double enemyX = centerX + offsetX;
                double enemyY = centerY + offsetY;
                
                // Keep enemies within room bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Randomly select an enemy type from the available options
                Enemy.EnemyType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                
                // Determine behavior type
                Enemy.BehaviorType behaviorType;
                double behaviorRand = random.nextDouble();
                if (behaviorRand < 0.6) {
                    behaviorType = Enemy.BehaviorType.AGGRESSIVE;
                } else if (behaviorRand < 0.8) {
                    behaviorType = Enemy.BehaviorType.RANGED;
                } else if (behaviorRand < 0.9) {
                    behaviorType = Enemy.BehaviorType.PATROLLER;
                } else {
                    behaviorType = Enemy.BehaviorType.AMBUSHER;
                }
                
                // Create enemy with the determined behavior type
                Enemy enemy = new Enemy(enemyX, enemyY, type, behaviorType, 1);
                
                // Scale enemy based on room depth and player level
                if (roomDepth > 2 || playerLevel > 2) {
                    double healthMultiplier = 1.0 + (roomDepth * 0.1) + ((playerLevel - 1) * 0.05);
                    enemy.setMaxHealth(enemy.getMaxHealth() * healthMultiplier);
                    enemy.heal(enemy.getMaxHealth()); // Set to full health
                }
                
                enemies.add(enemy);
                System.out.println("Added enemy at " + enemyX + "," + enemyY + " of type: " + type + 
                                  ", behavior: " + enemy.getBehavior());
            }
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Determine number of items based on room type
        switch (room.getType()) {
            case COMBAT:
                itemCount = random.nextInt(2); // 0-1 items
                break;
            case PUZZLE:
                itemCount = 1; // Always spawn a key
                // Add a key to unlock doors
                placeKeyInRoom(room);
                break;
            case TREASURE:
                itemCount = random.nextInt(3) + 2; // 2-4 items
                break;
            case BOSS:
                itemCount = random.nextInt(2) + 1; // 1-2 special items
                break;
            case SPAWN:
                // No items in spawn room
                return;
        }
        
        // Add random items
        for (int i = 0; i < itemCount; i++) {
            addItemToRoom(room);
        }
    }
    
    private void placeKeyInRoom(DungeonRoom room) {
        // Get the center of the room on the canvas
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        // Add some randomness to key position
        Random random = new Random();
        double keyX = centerX + (random.nextDouble() - 0.5) * 100;
        double keyY = centerY + (random.nextDouble() - 0.5) * 100;
        
        // Create and add the key
        Item roomKey = new Item("Room Key", "Opens locked doors", Item.ItemType.KEY, 1, true);
        roomKey.setX(keyX);
        roomKey.setY(keyY);
        roomKey.setSize(20);
        
        System.out.println("Added key at position: " + keyX + "," + keyY);
        roomItems.add(roomKey);
    }
    
    private void spawnBasicItem(Point2D position) {
        Random random = new Random();
        
        // Randomize item type
        Item.ItemType type;
        String name;
        String description;
        int value;
        boolean consumable;
        
        double rnd = random.nextDouble();
        if (rnd < 0.6) {
            // 60% chance for a potion
            type = Item.ItemType.POTION;
            name = "Health Potion";
            description = "Restores 20 health";
            value = 20;
            consumable = true;
        } else if (rnd < 0.8) {
            // 20% chance for a weapon
            type = Item.ItemType.WEAPON;
            name = "Sword";
            description = "A sharp weapon";
            value = 15;
            consumable = false;
        } else {
            // 20% chance for treasure
            type = Item.ItemType.TREASURE;
            name = "Gold Coins";
            description = "Valuable treasure";
            value = 50;
            consumable = true;
        }
        
        // Create the item
        Item item = new Item(name, description, type, value, consumable);
        item.setX(position.getX());
        item.setY(position.getY());
        item.setSize(20);
        
        System.out.println("Added item: " + name + " at " + position.getX() + "," + position.getY());
        
        roomItems.add(item);
    }
    
    private void spawnEnemy(DungeonRoom room) {
        Random random = new Random();
        Point2D roomPos = new Point2D(room.getX(), room.getY());
        Point2D randomOffset = new Point2D(
            random.nextDouble() * room.getWidth(),
            random.nextDouble() * room.getHeight()
        );
        Point2D spawnPos = roomPos.add(randomOffset).multiply(8); // Scale to pixel coordinates
        
        Enemy.EnemyType type = random.nextBoolean() ? Enemy.EnemyType.GOBLIN : Enemy.EnemyType.SKELETON;
        enemies.add(new Enemy(spawnPos.getX(), spawnPos.getY(), type));
    }

    private boolean isColliding(Entity entity1, Entity entity2) {
        Point2D center1 = entity1.getPosition().add(entity1.getSize() / 2, entity1.getSize() / 2);
        Point2D center2 = entity2.getPosition().add(entity2.getSize() / 2, entity2.getSize() / 2);
        double distance = center1.distance(center2);
        double combinedRadius = (entity1.getSize() + entity2.getSize()) / 2;
        return distance < combinedRadius;
    }

    private boolean isInMeleeRange(Entity attacker, Entity target) {
        double attackRange = 40; // Melee attack range
        
        Point2D attackerCenter = attacker.getPosition().add(new Point2D(attacker.getSize() / 2, attacker.getSize() / 2));
        Point2D targetCenter = target.getPosition().add(new Point2D(target.getSize() / 2, target.getSize() / 2));
        
        return attackerCenter.distance(targetCenter) < (attacker.getSize() / 2 + target.getSize() / 2 + attackRange);
    }

    private void showFloatingText(String text, Point2D position) {
        // This would be implemented with a UI element that floats up and fades out
        // For now, we'll just print to console
        System.out.println("Floating text at " + position + ": " + text);
    }

    private void dropRandomItem(Point2D position) {
        Random random = new Random();
        if (random.nextDouble() < 0.3) { // 30% chance to drop an item
            Item.ItemType type = Item.ItemType.values()[random.nextInt(Item.ItemType.values().length)];
            String name;
            String description;
            int value;
            boolean consumable;
            
            switch (type) {
                case WEAPON:
                    name = "Sword";
                    description = "A sharp blade";
                    value = 10;
                    consumable = false;
                    break;
                case POTION:
                    name = "Health Potion";
                    description = "Restores 20 HP";
                    value = 20;
                    consumable = true;
                    break;
                case ARMOR:
                    name = "Shield";
                    description = "Provides protection";
                    value = 15;
                    consumable = false;
                    break;
                default:
                    name = "Gold Coins";
                    description = "Valuable treasure";
                    value = 50;
                    consumable = true;
                    type = Item.ItemType.TREASURE;
                    break;
            }
            
            // Create and add the item
            Item item = new Item(name, description, type, value, consumable);
            item.setX(position.getX());
            item.setY(position.getY());
            item.setSize(20);
            roomItems.add(item);
        }
    }

    private boolean isPlayerTouchingItem(Item item) {
        double playerCenterX = player.getPosition().getX() + player.getSize() / 2;
        double playerCenterY = player.getPosition().getY() + player.getSize() / 2;
        double itemCenterX = item.getX() + 5; // Assuming item size is 10x10
        double itemCenterY = item.getY() + 5;
        
        double distance = Math.sqrt(
            Math.pow(playerCenterX - itemCenterX, 2) + 
            Math.pow(playerCenterY - itemCenterY, 2)
        );
        
        return distance < (player.getSize() / 2 + 5); // Player radius + item radius
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                System.out.println("Player touching door to " + door.getConnectedRoom().getType() + 
                                  " - Door locked: " + door.isLocked() + 
                                  ", Requires key: " + door.requiresKey());
                
                if (!door.isLocked()) {
                    // Get the connected room
                    DungeonRoom targetRoom = door.getConnectedRoom();
                    if (targetRoom != null) {
                        System.out.println("Door unlocked - transitioning to room: " + targetRoom.getType() + 
                                          " at position " + targetRoom.getX() + "," + targetRoom.getY());
                        
                        // Calculate entry position based on door direction
                        Point2D entryPosition = getEntryPosition(door);
                        
                        // Pass target room and entry position to transition method
                        transitionToRoom(targetRoom, entryPosition);
                        
                        // Update difficulty based on room type if it's a boss room
                        if (targetRoom.getType() == DungeonRoom.RoomType.BOSS) {
                            adjustDifficultyForLevel();
                        }
                        
                        break;
                    } else {
                        System.err.println("ERROR: Connected room is null!");
                    }
                } else {
                    // Show message about locked door if player is touching it
                    if (door.requiresKey()) {
                        effectsManager.showFloatingText("This door requires a key", 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.YELLOW);
                        
                        // Try to unlock with key if player has one
                        if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                            if (door.unlock(player.getInventory())) {
                                effectsManager.showFloatingText("Door unlocked!", 
                                    new Point2D(door.getX() + door.getWidth()/2, door.getY() - 10),
                                    Color.GREEN);
                                // Door is now unlocked, but wait for next check to transition
                            }
                        }
                    } else {
                        // Door is locked for other reasons (enemies not defeated)
                        String message = "Defeat all enemies to unlock";
                        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                            message = "Solve the puzzle to unlock";
                        }
                        effectsManager.showFloatingText(message, 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.RED);
                    }
                }
            }
        }
    }

    private void transitionToRoom(DungeonRoom room) {
        if (roomTransitionInProgress || room == null) {
            System.out.println("Cannot transition to room: " + (room == null ? "null" : room.getType()) + 
                               ", transition in progress: " + roomTransitionInProgress);
            return;
        }
        
        System.out.println("Starting transition to " + room.getType() + " room at position " + room.getX() + "," + room.getY());
        roomTransitionInProgress = true;
        
        // Create a fade transition effect
        Rectangle fadeRect = new Rectangle(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        fadeRect.setFill(Color.BLACK);
        fadeRect.setOpacity(0);
        rootPane.getChildren().add(fadeRect);
        
        // Create fade out transition
        javafx.animation.FadeTransition fadeOut = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeOut.setFromValue(0);
        fadeOut.setToValue(1);
        
        // Create fade in transition
        javafx.animation.FadeTransition fadeIn = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeIn.setFromValue(1);
        fadeIn.setToValue(0);
        
        // Add visual effects for room transition
        effectsManager.addRoomTransitionEffect();
        
        // Set up the sequence
        fadeOut.setOnFinished(e -> {
            // Change room
            currentRoom = room;
            currentRoom.setVisited(true);
            
            // Reset player position to center of new room
            double roomCenterX = currentRoom.getX() + currentRoom.getWidth() / 2 - player.getSize() / 2;
            double roomCenterY = currentRoom.getY() + currentRoom.getHeight() / 2 - player.getSize() / 2;
            player.setPosition(new Point2D(roomCenterX, roomCenterY));
            
            // Clear enemies and items from previous room
            enemies.clear();
            projectiles.clear();
            roomItems.clear();
            doors.clear();
            
            // Populate new room
            populateRoom(currentRoom);
            
            // Create doors for the new room
            createDoors();
            
            // Update minimap
            updateMinimap();
        });
        
        fadeIn.setOnFinished(e -> {
            // Remove the fade rectangle
            rootPane.getChildren().remove(fadeRect);
            roomTransitionInProgress = false;
            
            // Display room entrance message
            String roomTypeText = "";
            switch (currentRoom.getType()) {
                case COMBAT:
                    roomTypeText = "Combat Room";
                    break;
                case PUZZLE:
                    roomTypeText = "Puzzle Room";
                    break;
                case TREASURE:
                    roomTypeText = "Treasure Room";
                    break;
                case BOSS:
                    roomTypeText = "Boss Room";
                    break;
                case SPAWN:
                    roomTypeText = "Starting Room";
                    break;
            }
            
            // Show floating text for room type
            showFloatingText("Entered: " + roomTypeText, 
                new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4));
                
            // Initialize room-specific lighting
            updateLighting();
        });
        
        // Start the transition
        fadeOut.play();
    }
    
    private void handleDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item name for debug or when player is close
            if (isDebugMode || (player != null && 
                player.getPosition().distance(new Point2D(item.getX(), item.getY())) < 100)) {
                gc.setFill(Color.WHITE);
                gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                gc.fillText(item.getName(), item.getX() - 20, item.getY() - 10);
            }
        }
        
        // Draw enemies
        if (enemies.isEmpty()) {
            System.out.println("No enemies to render in current room");
        } else {
            System.out.println("Rendering " + enemies.size() + " enemies");
            for (Enemy enemy : enemies) {
                System.out.println("Rendering enemy at: " + enemy.getX() + "," + enemy.getY() + " of type: " + enemy.getType());
                // Draw enemy as a red rectangle
                if (enemy.getType() == Enemy.EnemyType.BOSS) {
                    gc.setFill(Color.DARKRED);
                    // Draw boss larger
                    gc.fillRect(enemy.getX() - 5, enemy.getY() - 5, enemy.getSize() + 10, enemy.getSize() + 10);
                } else {
                    gc.setFill(Color.RED);
                    gc.fillRect(enemy.getX(), enemy.getY(), enemy.getSize(), enemy.getSize());
                }
                
                // Draw enemy health bar
                double healthPercentage = (double) enemy.getHealth() / enemy.getMaxHealth();
                double healthBarWidth = enemy.getSize() * healthPercentage;
                
                gc.setFill(Color.BLACK);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, enemy.getSize(), 5);
                gc.setFill(Color.GREEN);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, healthBarWidth, 5);
                
                // Draw enemy type if debug mode is on
                if (isDebugMode) {
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(enemy.getType().toString(), enemy.getX(), enemy.getY() - 12);
                }
            }
        }
        
        // Draw player projectiles
        for (ProjectileAttack attack : playerProjectiles) {
            attack.render(gc);
        }
        
        // Draw projectiles
        for (Projectile projectile : projectiles) {
            projectile.render(gc);
        }
        
        // Draw the player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw UI elements
        renderUI(gc);
    }
    
    private void drawPauseButton(GraphicsContext gc) {
        // Draw pause button in top-right corner
        double buttonSize = 30;
        double padding = 10;
        double x = gameCanvas.getWidth() - buttonSize - padding;
        double y = padding;
        
        // Draw button background
        gc.setFill(Color.DARKGRAY);
        gc.fillRoundRect(x, y, buttonSize, buttonSize, 5, 5);
        
        // Draw pause icon
        gc.setFill(Color.WHITE);
        gc.fillRect(x + buttonSize * 0.3, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        gc.fillRect(x + buttonSize * 0.55, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        
        // Draw button border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(x, y, buttonSize, buttonSize, 5, 5);
    }
    
    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            gc.setFill(Color.BLACK);
            gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
            return;
        }
        
        System.out.println("Drawing background for room type: " + currentRoom.getType());
        
        // Set the base background color based on room type
        Color baseColor;
        switch (currentRoom.getType()) {
            case SPAWN:
                baseColor = Color.rgb(0, 80, 0); // Dark green for spawn
                break;
            case COMBAT:
                baseColor = Color.rgb(70, 30, 30); // Dark red for combat
                break;
            case PUZZLE:
                baseColor = Color.rgb(30, 30, 80); // Dark blue for puzzle
                break;
            case TREASURE:
                baseColor = Color.rgb(80, 80, 30); // Gold for treasure
                break;
            case BOSS:
                baseColor = Color.rgb(80, 0, 0); // Deep red for boss
                break;
            default:
                baseColor = Color.rgb(30, 30, 30); // Dark gray default
                break;
        }
        
        // Fill the entire canvas with the base color
        gc.setFill(baseColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw floor tiles based on room type
        double tileSize = 40;
        
        switch (currentRoom.getType()) {
            case COMBAT:
                drawCombatRoomFloor(gc, tileSize);
                break;
            case PUZZLE:
                drawPuzzleRoomFloor(gc, tileSize);
                break;
            case TREASURE:
                drawTreasureRoomFloor(gc, tileSize);
                break;
            case BOSS:
                drawBossRoomFloor(gc, tileSize);
                break;
            case SPAWN:
            default:
                drawSpawnRoomFloor(gc, tileSize);
                break;
        }
        
        // Draw room borders
        gc.setStroke(Color.DARKGRAY);
        gc.setLineWidth(5);
        gc.strokeRect(10, 10, gameCanvas.getWidth() - 20, gameCanvas.getHeight() - 20);
    }
    
    private void drawCombatRoomFloor(GraphicsContext gc, double tileSize) {
        // Checkered pattern in dark red
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(60, 20, 20));
                } else {
                    gc.setFill(Color.rgb(40, 10, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add some blood stains
        gc.setFill(Color.rgb(120, 0, 0, 0.3));
        for (int i = 0; i < 10; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 20 + random.nextDouble() * 30;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawPuzzleRoomFloor(GraphicsContext gc, double tileSize) {
        // Blue tiled pattern with symbols
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(20, 30, 50));
                gc.fillRect(x, y, tileSize, tileSize);
                
                // Add tile borders
                gc.setStroke(Color.rgb(30, 40, 70));
                gc.strokeRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add arcane symbols
        gc.setFill(Color.rgb(100, 150, 255, 0.2));
        for (int i = 0; i < 8; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 30 + random.nextDouble() * 40;
            
            // Draw a random arcane symbol (simplified)
            double angle = random.nextDouble() * Math.PI * 2;
            double[] xPoints = new double[5];
            double[] yPoints = new double[5];
            
            for (int j = 0; j < 5; j++) {
                xPoints[j] = x + Math.cos(angle + j * Math.PI * 2 / 5) * size / 2;
                yPoints[j] = y + Math.sin(angle + j * Math.PI * 2 / 5) * size / 2;
            }
            
            gc.fillPolygon(xPoints, yPoints, 5);
        }
    }
    
    private void drawTreasureRoomFloor(GraphicsContext gc, double tileSize) {
        // Gold/yellow tiled pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(80, 70, 20));
                } else {
                    gc.setFill(Color.rgb(60, 50, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add gold coins scattered around
        gc.setFill(Color.GOLD);
        for (int i = 0; i < 30; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 3 + random.nextDouble() * 5;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawBossRoomFloor(GraphicsContext gc, double tileSize) {
        // Dark pattern with lava cracks
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(30, 10, 10));
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add lava cracks
        gc.setFill(Color.rgb(255, 50, 0, 0.7));
        for (int i = 0; i < 15; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double width = 5 + random.nextDouble() * 100;
            double height = 3 + random.nextDouble() * 5;
            double angle = random.nextDouble() * Math.PI;
            
            gc.save();
            gc.translate(x, y);
            gc.rotate(Math.toDegrees(angle));
            gc.fillRect(-width/2, -height/2, width, height);
            gc.restore();
        }
    }
    
    private void drawSpawnRoomFloor(GraphicsContext gc, double tileSize) {
        // Green/brown natural pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(30, 50, 30));
                } else {
                    gc.setFill(Color.rgb(40, 60, 40));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
    }
    
    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Clear previous lights
        lightingEffect.clearLights();
        
        // Set ambient light based on room type
        switch (currentRoom.getType()) {
            case COMBAT:
                lightingEffect.setAmbientLight(0.3); // Dim red lighting
                break;
                
            case PUZZLE:
                lightingEffect.setAmbientLight(0.4); // Moderate blue lighting
                break;
                
            case TREASURE:
                lightingEffect.setAmbientLight(0.5); // Brighter gold lighting
                break;
                
            case BOSS:
                lightingEffect.setAmbientLight(0.2); // Very dark with red tint
                break;
                
            case SPAWN:
            default:
                lightingEffect.setAmbientLight(0.6); // Bright natural lighting
                break;
        }
        
        // Add player light
        lightingEffect.addLightSource(
            player.getPosition(), 
            150, 
            Color.WHITE, 
            LightingEffect.LightSource.LightType.FLICKERING
        );
        
        // Add door lights
        for (Door door : doors) {
            Color lightColor = door.isLocked() ? Color.RED : Color.GREEN;
            lightingEffect.addLightSource(
                new Point2D(door.getX() + door.getWidth()/2, door.getY() + door.getHeight()/2),
                60,
                lightColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add item lights
        for (Item item : roomItems) {
            Color itemColor = getItemColor(item.getType());
            lightingEffect.addLightSource(
                new Point2D(item.getX(), item.getY()),
                item.getSize() * 3,
                itemColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add enemy lights
        for (Enemy enemy : enemies) {
            Color enemyColor = Color.RED;
            if (enemy.getType() == Enemy.EnemyType.BOSS) {
                enemyColor = Color.DARKRED;
            } else if (enemy.getType() == Enemy.EnemyType.MAGE) {
                enemyColor = Color.BLUE;
            }
            
            lightingEffect.addLightSource(
                enemy.getPosition(),
                enemy.getSize() * 2,
                enemyColor,
                enemy.getType() == Enemy.EnemyType.BOSS ? 
                    LightingEffect.LightSource.LightType.PULSING : 
                    LightingEffect.LightSource.LightType.FLICKERING
            );
        }
        
        // Add environmental lights based on room type
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
            // Add lava lights for boss room
            for (int i = 0; i < 5; i++) {
                double x = random.nextDouble() * gameCanvas.getWidth();
                double y = random.nextDouble() * gameCanvas.getHeight();
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    30 + random.nextDouble() * 50,
                    Color.ORANGE,
                    LightingEffect.LightSource.LightType.FLICKERING
                );
            }
        } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            // Add arcane lights for puzzle room
            for (int i = 0; i < 4; i++) {
                double x = 100 + i * (gameCanvas.getWidth() - 200) / 3;
                double y = gameCanvas.getHeight() / 2;
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    70,
                    Color.CYAN,
                    LightingEffect.LightSource.LightType.PULSING
                );
            }
        }
    }
    
    private void renderUI(GraphicsContext gc) {
        if (player == null) return;
        
        // Set up fonts
        Font titleFont = Font.font("Arial", FontWeight.BOLD, 16);
        Font normalFont = Font.font("Arial", FontWeight.NORMAL, 14);
        
        // Draw player health bar
        double healthBarWidth = 200;
        double healthBarHeight = 20;
        double healthPercentage = (double) player.getHealth() / player.getMaxHealth();
        
        // Health bar background
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health bar fill
        Color healthColor;
        if (healthPercentage > 0.7) {
            healthColor = Color.GREEN;
        } else if (healthPercentage > 0.3) {
            healthColor = Color.YELLOW;
        } else {
            healthColor = Color.RED;
        }
        
        gc.setFill(healthColor);
        gc.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
        
        // Health bar border
        gc.setStroke(Color.BLACK);
        gc.setLineWidth(2);
        gc.strokeRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health text
        gc.setFill(Color.WHITE);
        gc.setFont(normalFont);
        gc.fillText("HP: " + (int)player.getHealth() + "/" + (int)player.getMaxHealth(), 
                    25, 36);
        
        // Draw current weapon info
        String weaponText = "Weapon: " + player.getCurrentWeapon().getType().getName();
        gc.fillText(weaponText, 20, 60);
        
        // Draw score
        gc.setFont(normalFont);
        gc.fillText("Score: " + player.getScore(), 20, 80);
        
        // Draw enemy count
        gc.fillText("Enemies: " + enemies.size(), 20, 100);
        
        // Draw level info
        gc.fillText("Level: " + currentLevel, 20, 120);
        
        // Draw current room type
        String roomTypeText = "Room: " + (currentRoom != null ? currentRoom.getType().toString() : "UNKNOWN");
        gc.fillText(roomTypeText, 20, 140);
        
        // Draw mini-map in top-right corner if needed
        if (isDebugMode) {
            drawMiniMap(gc);
        }
        
        // Draw FPS counter in debug mode
        if (isDebugMode) {
            long currentTime = System.nanoTime();
            double fps = 1_000_000_000.0 / (currentTime - lastUpdateTime);
            gc.fillText(String.format("FPS: %.1f", fps), gameCanvas.getWidth() - 100, 20);
        }
        
        // Controls reminder at the bottom
        gc.setFill(Color.LIGHTBLUE);
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                   gameCanvas.getWidth() / 2 - 200, gameCanvas.getHeight() - 20);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        double cellSize = 10;
        
        // Draw mini-map background
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw mini-map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Find min/max coordinates to center the map
        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
        
        for (DungeonRoom room : currentDungeon) {
            minX = Math.min(minX, room.getX());
            minY = Math.min(minY, room.getY());
            maxX = Math.max(maxX, room.getX());
            maxY = Math.max(maxY, room.getY());
        }
        
        // Calculate scaling to fit all rooms
        int mapWidth = maxX - minX + 1;
        int mapHeight = maxY - minY + 1;
        double scaleX = mapSize / (mapWidth * 1.5);
        double scaleY = mapSize / (mapHeight * 1.5);
        double scale = Math.min(scaleX, scaleY);
        
        // Calculate offset to center the map
        double offsetX = mapX + (mapSize - mapWidth * scale) / 2;
        double offsetY = mapY + (mapSize - mapHeight * scale) / 2;
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = offsetX + (room.getX() - minX) * scale;
            double roomY = offsetY + (room.getY() - minY) * scale;
            
            // Choose color based on room type
            Color roomColor;
            switch (room.getType()) {
                case SPAWN:
                    roomColor = Color.GREEN;
                    break;
                case BOSS:
                    roomColor = Color.RED;
                    break;
                case PUZZLE:
                    roomColor = Color.BLUE;
                    break;
                case TREASURE:
                    roomColor = Color.GOLD;
                    break;
                default:
                    roomColor = Color.GRAY;
            }
            
            // Draw room
            gc.setFill(room.isVisited() ? roomColor : Color.DARKGRAY);
            gc.fillRect(roomX, roomY, scale * 0.8, scale * 0.8);
            
            // If this is the current room, highlight it
            if (room == currentRoom) {
                gc.setStroke(Color.WHITE);
                gc.setLineWidth(2);
                gc.strokeRect(roomX, roomY, scale * 0.8, scale * 0.8);
            }
        }
        
        // Draw minimap legend
        double legendX = mapX + 10;
        double legendY = mapY + mapSize + 10;
        double legendBoxSize = 8;
        double textOffset = 15;
        
        gc.setFont(Font.font("Arial", FontWeight.NORMAL, 10));
        
        // Current room
        gc.setFill(Color.WHITE);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.fillText("Current", legendX + legendBoxSize + 5, legendY + 8);
        
        // Spawn room
        legendY += textOffset;
        gc.setFill(Color.GREEN);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Spawn", legendX + legendBoxSize + 5, legendY + 8);
        
        // Boss room
        legendY += textOffset;
        gc.setFill(Color.RED);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Boss", legendX + legendBoxSize + 5, legendY + 8);
        
        // Unvisited room
        legendY += textOffset;
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Unexplored", legendX + legendBoxSize + 5, legendY + 8);
    }

    public Player getPlayer() {
        return player;
    }

    private Color getItemColor(Item.ItemType type) {
        switch (type) {
            case WEAPON: return Color.RED;
            case POTION: return Color.GREEN;
            case ARMOR: return Color.BLUE;
            default: return Color.WHITE;
        }
    }

    private void createDoors() {
        // First remove existing doors
        doors.clear();
        
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors for null room");
            return;
        }
        
        System.out.println("Creating doors for room " + currentRoom.getType() + 
                          " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")");
        
        List<DungeonRoom> connectedRooms = currentRoom.getConnectedRooms();
        System.out.println("Connected rooms: " + connectedRooms.size());
        
        if (connectedRooms.isEmpty()) {
            System.err.println("WARNING: Room has no connected rooms!");
            return;
        }
        
        // Determine room bounds on the canvas
        double roomWidth = gameCanvas.getWidth() - 100;  // 50px margin on each side
        double roomHeight = gameCanvas.getHeight() - 100;
        double doorWidth = DOOR_WIDTH;
        double doorHeight = DOOR_HEIGHT;
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : connectedRooms) {
            if (connectedRoom == null) {
                System.err.println("WARNING: Connected room is null!");
                continue;
            }
            
            // Determine direction to the connected room
            int dx = connectedRoom.getX() - currentRoom.getX();
            int dy = connectedRoom.getY() - currentRoom.getY();
            
            System.out.println("Adding door to " + connectedRoom.getType() + 
                              " at direction (" + dx + "," + dy + ")");
            
            // Calculate door position based on direction
            double doorX, doorY;
            Door.DoorDirection doorDirection;
            
            if (dx > 0) {      // East door
                doorX = roomWidth - doorWidth + 50;
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.EAST;
            } else if (dx < 0) { // West door
                doorX = 50;  // Left margin
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.WEST;
            } else if (dy > 0) { // South door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = roomHeight - doorHeight + 50;
                doorDirection = Door.DoorDirection.SOUTH;
            } else {            // North door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = 50;  // Top margin
                doorDirection = Door.DoorDirection.NORTH;
            }
            
            // Create the door
            Door door = new Door(
                doorX, doorY, doorWidth, doorHeight,
                currentRoom, connectedRoom, doorDirection
            );
            
            // Lock doors based on room type
            if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT ||
                currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                // Combat rooms: doors are locked until enemies are defeated
                door.setLocked(!enemies.isEmpty());
                System.out.println("Combat/Boss room door locked state: " + door.isLocked() + 
                                 " (enemies: " + enemies.size() + ")");
            } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Puzzle rooms: doors are locked until puzzle is solved
                door.setLocked(!puzzleCompleted);
                door.setRequiresKey(true);
                System.out.println("Puzzle room door locked state: " + door.isLocked() + 
                                 " (puzzle completed: " + puzzleCompleted + ")");
            }
            
            doors.add(door);
            System.out.println("Added door at " + doorX + "," + doorY + 
                              " to " + connectedRoom.getType() + 
                              " (locked: " + door.isLocked() + ", requires key: " + door.requiresKey() + ")");
        }
        
        // Debug output of created doors
        if (doors.isEmpty()) {
            System.err.println("WARNING: No doors were created!");
        } else {
            System.out.println("Created " + doors.size() + " doors");
        }
    }
    
    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        roomCleared = false;
        
        System.out.println("Populating room of type: " + room.getType() + " at position " + room.getX() + "," + room.getY());
        
        // Get room center
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        Point2D roomCenter = new Point2D(centerX, centerY);
        
        switch (room.getType()) {
            case COMBAT:
                // Add enemies in combat rooms
                spawnEnemiesForRoom(room, false);
                
                // Add a health potion
                if (new Random().nextDouble() < 0.5) {
                    spawnBasicItem(roomCenter.add(50, 50));
                    System.out.println("Added health potion to combat room");
                }
                break;
                
            case BOSS:
                // Add boss enemy with enhanced spawning
                spawnEnemiesForRoom(room, true);
                break;
                
            case TREASURE:
                // Add random items
                System.out.println("Spawning items in treasure room");
                Random rnd = new Random();
                int itemCount = 2 + rnd.nextInt(3); // 2-4 items
                
                for (int i = 0; i < itemCount; i++) {
                    double angle = rnd.nextDouble() * Math.PI * 2; // Random angle
                    double distance = 50 + rnd.nextDouble() * 100; // Distance from center
                    
                    double offsetX = Math.cos(angle) * distance;
                    double offsetY = Math.sin(angle) * distance;
                    
                    spawnBasicItem(roomCenter.add(offsetX, offsetY));
                }
                break;
                
            case PUZZLE:
                // Add a key
                System.out.println("Adding key to puzzle room");
                placeKeyInRoom(room);
                break;
                
            case SPAWN:
            default:
                // No special spawns in spawn room
                break;
        }
        
        // Create doors for the new room
        createDoors();
    }
    
    /**
     * Enhanced enemy spawning system for rooms
     */
    private void spawnEnemiesForRoom(DungeonRoom room, boolean isBossRoom) {
        Random random = new Random();
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        if (isBossRoom) {
            System.out.println("Spawning boss in boss room");
            // Create a boss enemy
            Enemy bossEnemy = new Enemy(centerX, centerY, Enemy.EnemyType.BOSS);
            
            // Double the boss's max health and increase damage
            bossEnemy.setMaxHealth(bossEnemy.getMaxHealth() * 2);
            bossEnemy.heal(bossEnemy.getMaxHealth()); // Heal to full health
            
            // Add the boss
            enemies.add(bossEnemy);
            
            // Add minions around the boss
            int minionCount = 1 + random.nextInt(2); // 1-2 minions
            for (int i = 0; i < minionCount; i++) {
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 120 + random.nextInt(50);
                
                double enemyX = centerX + Math.cos(angle) * distance;
                double enemyY = centerY + Math.sin(angle) * distance;
                
                // Keep within bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Create a minion (using the constructor with behavior parameter)
                Enemy minion = new Enemy(enemyX, enemyY, Enemy.EnemyType.SKELETON, Enemy.BehaviorType.AGGRESSIVE, 1);
                enemies.add(minion);
            }
            
            System.out.println("Spawned boss with " + minionCount + " minions");
        } else {
            // Regular combat room
            int playerLevel = player != null ? player.getLevel() : 1;
            int roomDepth = Math.abs(room.getX()) + Math.abs(room.getY());
            
            // Adjust enemy count based on player level and room distance from spawn
            int baseEnemyCount = 2;
            int levelBonus = (playerLevel - 1) / 2; // Every 2 levels adds an enemy
            int depthBonus = roomDepth / 3; // Every 3 rooms deeper adds an enemy
            int maxEnemyCount = Math.min(6, baseEnemyCount + levelBonus + depthBonus);
            int enemyCount = baseEnemyCount + random.nextInt(maxEnemyCount - baseEnemyCount + 1);
            
            System.out.println("Spawning " + enemyCount + " enemies in combat room (player level: " + 
                              playerLevel + ", room depth: " + roomDepth + ")");
            
            // Determine possible enemy types based on depth
            List<Enemy.EnemyType> possibleTypes = new ArrayList<>();
            possibleTypes.add(Enemy.EnemyType.GOBLIN);  // Always available
            
            if (roomDepth > 1 || playerLevel > 1) {
                possibleTypes.add(Enemy.EnemyType.SKELETON);
            }
            
            if (roomDepth > 3 || playerLevel > 3) {
                possibleTypes.add(Enemy.EnemyType.ORC);
            }
            
            if (roomDepth > 5 || playerLevel > 5) {
                possibleTypes.add(Enemy.EnemyType.MAGE);
            }
            
            // Spawn enemies
            for (int i = 0; i < enemyCount; i++) {
                // Calculate random position within the room, away from center
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 100 + random.nextDouble() * 150;
                
                double offsetX = Math.cos(angle) * distance;
                double offsetY = Math.sin(angle) * distance;
                
                double enemyX = centerX + offsetX;
                double enemyY = centerY + offsetY;
                
                // Keep enemies within room bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Randomly select an enemy type from the available options
                Enemy.EnemyType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                
                // Determine behavior type
                Enemy.BehaviorType behaviorType;
                double behaviorRand = random.nextDouble();
                if (behaviorRand < 0.6) {
                    behaviorType = Enemy.BehaviorType.AGGRESSIVE;
                } else if (behaviorRand < 0.8) {
                    behaviorType = Enemy.BehaviorType.RANGED;
                } else if (behaviorRand < 0.9) {
                    behaviorType = Enemy.BehaviorType.PATROLLER;
                } else {
                    behaviorType = Enemy.BehaviorType.AMBUSHER;
                }
                
                // Create enemy with the determined behavior type
                Enemy enemy = new Enemy(enemyX, enemyY, type, behaviorType, 1);
                
                // Scale enemy based on room depth and player level
                if (roomDepth > 2 || playerLevel > 2) {
                    double healthMultiplier = 1.0 + (roomDepth * 0.1) + ((playerLevel - 1) * 0.05);
                    enemy.setMaxHealth(enemy.getMaxHealth() * healthMultiplier);
                    enemy.heal(enemy.getMaxHealth()); // Set to full health
                }
                
                enemies.add(enemy);
                System.out.println("Added enemy at " + enemyX + "," + enemyY + " of type: " + type + 
                                  ", behavior: " + enemy.getBehavior());
            }
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Determine number of items based on room type
        switch (room.getType()) {
            case COMBAT:
                itemCount = random.nextInt(2); // 0-1 items
                break;
            case PUZZLE:
                itemCount = 1; // Always spawn a key
                // Add a key to unlock doors
                placeKeyInRoom(room);
                break;
            case TREASURE:
                itemCount = random.nextInt(3) + 2; // 2-4 items
                break;
            case BOSS:
                itemCount = random.nextInt(2) + 1; // 1-2 special items
                break;
            case SPAWN:
                // No items in spawn room
                return;
        }
        
        // Add random items
        for (int i = 0; i < itemCount; i++) {
            addItemToRoom(room);
        }
    }
    
    private void placeKeyInRoom(DungeonRoom room) {
        // Get the center of the room on the canvas
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        // Add some randomness to key position
        Random random = new Random();
        double keyX = centerX + (random.nextDouble() - 0.5) * 100;
        double keyY = centerY + (random.nextDouble() - 0.5) * 100;
        
        // Create and add the key
        Item roomKey = new Item("Room Key", "Opens locked doors", Item.ItemType.KEY, 1, true);
        roomKey.setX(keyX);
        roomKey.setY(keyY);
        roomKey.setSize(20);
        
        System.out.println("Added key at position: " + keyX + "," + keyY);
        roomItems.add(roomKey);
    }
    
    private void spawnBasicItem(Point2D position) {
        Random random = new Random();
        
        // Randomize item type
        Item.ItemType type;
        String name;
        String description;
        int value;
        boolean consumable;
        
        double rnd = random.nextDouble();
        if (rnd < 0.6) {
            // 60% chance for a potion
            type = Item.ItemType.POTION;
            name = "Health Potion";
            description = "Restores 20 health";
            value = 20;
            consumable = true;
        } else if (rnd < 0.8) {
            // 20% chance for a weapon
            type = Item.ItemType.WEAPON;
            name = "Sword";
            description = "A sharp weapon";
            value = 15;
            consumable = false;
        } else {
            // 20% chance for treasure
            type = Item.ItemType.TREASURE;
            name = "Gold Coins";
            description = "Valuable treasure";
            value = 50;
            consumable = true;
        }
        
        // Create the item
        Item item = new Item(name, description, type, value, consumable);
        item.setX(position.getX());
        item.setY(position.getY());
        item.setSize(20);
        
        System.out.println("Added item: " + name + " at " + position.getX() + "," + position.getY());
        
        roomItems.add(item);
    }
    
    private void spawnEnemy(DungeonRoom room) {
        Random random = new Random();
        Point2D roomPos = new Point2D(room.getX(), room.getY());
        Point2D randomOffset = new Point2D(
            random.nextDouble() * room.getWidth(),
            random.nextDouble() * room.getHeight()
        );
        Point2D spawnPos = roomPos.add(randomOffset).multiply(8); // Scale to pixel coordinates
        
        Enemy.EnemyType type = random.nextBoolean() ? Enemy.EnemyType.GOBLIN : Enemy.EnemyType.SKELETON;
        enemies.add(new Enemy(spawnPos.getX(), spawnPos.getY(), type));
    }

    private boolean isColliding(Entity entity1, Entity entity2) {
        Point2D center1 = entity1.getPosition().add(entity1.getSize() / 2, entity1.getSize() / 2);
        Point2D center2 = entity2.getPosition().add(entity2.getSize() / 2, entity2.getSize() / 2);
        double distance = center1.distance(center2);
        double combinedRadius = (entity1.getSize() + entity2.getSize()) / 2;
        return distance < combinedRadius;
    }

    private boolean isInMeleeRange(Entity attacker, Entity target) {
        double attackRange = 40; // Melee attack range
        
        Point2D attackerCenter = attacker.getPosition().add(new Point2D(attacker.getSize() / 2, attacker.getSize() / 2));
        Point2D targetCenter = target.getPosition().add(new Point2D(target.getSize() / 2, target.getSize() / 2));
        
        return attackerCenter.distance(targetCenter) < (attacker.getSize() / 2 + target.getSize() / 2 + attackRange);
    }

    private void showFloatingText(String text, Point2D position) {
        // This would be implemented with a UI element that floats up and fades out
        // For now, we'll just print to console
        System.out.println("Floating text at " + position + ": " + text);
    }

    private void dropRandomItem(Point2D position) {
        Random random = new Random();
        if (random.nextDouble() < 0.3) { // 30% chance to drop an item
            Item.ItemType type = Item.ItemType.values()[random.nextInt(Item.ItemType.values().length)];
            String name;
            String description;
            int value;
            boolean consumable;
            
            switch (type) {
                case WEAPON:
                    name = "Sword";
                    description = "A sharp blade";
                    value = 10;
                    consumable = false;
                    break;
                case POTION:
                    name = "Health Potion";
                    description = "Restores 20 HP";
                    value = 20;
                    consumable = true;
                    break;
                case ARMOR:
                    name = "Shield";
                    description = "Provides protection";
                    value = 15;
                    consumable = false;
                    break;
                default:
                    name = "Gold Coins";
                    description = "Valuable treasure";
                    value = 50;
                    consumable = true;
                    type = Item.ItemType.TREASURE;
                    break;
            }
            
            // Create and add the item
            Item item = new Item(name, description, type, value, consumable);
            item.setX(position.getX());
            item.setY(position.getY());
            item.setSize(20);
            roomItems.add(item);
        }
    }

    private boolean isPlayerTouchingItem(Item item) {
        double playerCenterX = player.getPosition().getX() + player.getSize() / 2;
        double playerCenterY = player.getPosition().getY() + player.getSize() / 2;
        double itemCenterX = item.getX() + 5; // Assuming item size is 10x10
        double itemCenterY = item.getY() + 5;
        
        double distance = Math.sqrt(
            Math.pow(playerCenterX - itemCenterX, 2) + 
            Math.pow(playerCenterY - itemCenterY, 2)
        );
        
        return distance < (player.getSize() / 2 + 5); // Player radius + item radius
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                System.out.println("Player touching door to " + door.getConnectedRoom().getType() + 
                                  " - Door locked: " + door.isLocked() + 
                                  ", Requires key: " + door.requiresKey());
                
                if (!door.isLocked()) {
                    // Get the connected room
                    DungeonRoom targetRoom = door.getConnectedRoom();
                    if (targetRoom != null) {
                        System.out.println("Door unlocked - transitioning to room: " + targetRoom.getType() + 
                                          " at position " + targetRoom.getX() + "," + targetRoom.getY());
                        
                        // Calculate entry position based on door direction
                        Point2D entryPosition = getEntryPosition(door);
                        
                        // Pass target room and entry position to transition method
                        transitionToRoom(targetRoom, entryPosition);
                        
                        // Update difficulty based on room type if it's a boss room
                        if (targetRoom.getType() == DungeonRoom.RoomType.BOSS) {
                            adjustDifficultyForLevel();
                        }
                        
                        break;
                    } else {
                        System.err.println("ERROR: Connected room is null!");
                    }
                } else {
                    // Show message about locked door if player is touching it
                    if (door.requiresKey()) {
                        effectsManager.showFloatingText("This door requires a key", 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.YELLOW);
                        
                        // Try to unlock with key if player has one
                        if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                            if (door.unlock(player.getInventory())) {
                                effectsManager.showFloatingText("Door unlocked!", 
                                    new Point2D(door.getX() + door.getWidth()/2, door.getY() - 10),
                                    Color.GREEN);
                                // Door is now unlocked, but wait for next check to transition
                            }
                        }
                    } else {
                        // Door is locked for other reasons (enemies not defeated)
                        String message = "Defeat all enemies to unlock";
                        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                            message = "Solve the puzzle to unlock";
                        }
                        effectsManager.showFloatingText(message, 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.RED);
                    }
                }
            }
        }
    }

    private void transitionToRoom(DungeonRoom room) {
        if (roomTransitionInProgress || room == null) {
            System.out.println("Cannot transition to room: " + (room == null ? "null" : room.getType()) + 
                               ", transition in progress: " + roomTransitionInProgress);
            return;
        }
        
        System.out.println("Starting transition to " + room.getType() + " room at position " + room.getX() + "," + room.getY());
        roomTransitionInProgress = true;
        
        // Create a fade transition effect
        Rectangle fadeRect = new Rectangle(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        fadeRect.setFill(Color.BLACK);
        fadeRect.setOpacity(0);
        rootPane.getChildren().add(fadeRect);
        
        // Create fade out transition
        javafx.animation.FadeTransition fadeOut = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeOut.setFromValue(0);
        fadeOut.setToValue(1);
        
        // Create fade in transition
        javafx.animation.FadeTransition fadeIn = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeIn.setFromValue(1);
        fadeIn.setToValue(0);
        
        // Add visual effects for room transition
        effectsManager.addRoomTransitionEffect();
        
        // Set up the sequence
        fadeOut.setOnFinished(e -> {
            // Change room
            currentRoom = room;
            currentRoom.setVisited(true);
            
            // Reset player position to center of new room
            double roomCenterX = currentRoom.getX() + currentRoom.getWidth() / 2 - player.getSize() / 2;
            double roomCenterY = currentRoom.getY() + currentRoom.getHeight() / 2 - player.getSize() / 2;
            player.setPosition(new Point2D(roomCenterX, roomCenterY));
            
            // Clear enemies and items from previous room
            enemies.clear();
            projectiles.clear();
            roomItems.clear();
            doors.clear();
            
            // Populate new room
            populateRoom(currentRoom);
            
            // Create doors for the new room
            createDoors();
            
            // Update minimap
            updateMinimap();
        });
        
        fadeIn.setOnFinished(e -> {
            // Remove the fade rectangle
            rootPane.getChildren().remove(fadeRect);
            roomTransitionInProgress = false;
            
            // Display room entrance message
            String roomTypeText = "";
            switch (currentRoom.getType()) {
                case COMBAT:
                    roomTypeText = "Combat Room";
                    break;
                case PUZZLE:
                    roomTypeText = "Puzzle Room";
                    break;
                case TREASURE:
                    roomTypeText = "Treasure Room";
                    break;
                case BOSS:
                    roomTypeText = "Boss Room";
                    break;
                case SPAWN:
                    roomTypeText = "Starting Room";
                    break;
            }
            
            // Show floating text for room type
            showFloatingText("Entered: " + roomTypeText, 
                new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4));
                
            // Initialize room-specific lighting
            updateLighting();
        });
        
        // Start the transition
        fadeOut.play();
    }
    
    private void handleDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item name for debug or when player is close
            if (isDebugMode || (player != null && 
                player.getPosition().distance(new Point2D(item.getX(), item.getY())) < 100)) {
                gc.setFill(Color.WHITE);
                gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                gc.fillText(item.getName(), item.getX() - 20, item.getY() - 10);
            }
        }
        
        // Draw enemies
        if (enemies.isEmpty()) {
            System.out.println("No enemies to render in current room");
        } else {
            System.out.println("Rendering " + enemies.size() + " enemies");
            for (Enemy enemy : enemies) {
                System.out.println("Rendering enemy at: " + enemy.getX() + "," + enemy.getY() + " of type: " + enemy.getType());
                // Draw enemy as a red rectangle
                if (enemy.getType() == Enemy.EnemyType.BOSS) {
                    gc.setFill(Color.DARKRED);
                    // Draw boss larger
                    gc.fillRect(enemy.getX() - 5, enemy.getY() - 5, enemy.getSize() + 10, enemy.getSize() + 10);
                } else {
                    gc.setFill(Color.RED);
                    gc.fillRect(enemy.getX(), enemy.getY(), enemy.getSize(), enemy.getSize());
                }
                
                // Draw enemy health bar
                double healthPercentage = (double) enemy.getHealth() / enemy.getMaxHealth();
                double healthBarWidth = enemy.getSize() * healthPercentage;
                
                gc.setFill(Color.BLACK);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, enemy.getSize(), 5);
                gc.setFill(Color.GREEN);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, healthBarWidth, 5);
                
                // Draw enemy type if debug mode is on
                if (isDebugMode) {
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(enemy.getType().toString(), enemy.getX(), enemy.getY() - 12);
                }
            }
        }
        
        // Draw player projectiles
        for (ProjectileAttack attack : playerProjectiles) {
            attack.render(gc);
        }
        
        // Draw projectiles
        for (Projectile projectile : projectiles) {
            projectile.render(gc);
        }
        
        // Draw the player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw UI elements
        renderUI(gc);
    }
    
    private void drawPauseButton(GraphicsContext gc) {
        // Draw pause button in top-right corner
        double buttonSize = 30;
        double padding = 10;
        double x = gameCanvas.getWidth() - buttonSize - padding;
        double y = padding;
        
        // Draw button background
        gc.setFill(Color.DARKGRAY);
        gc.fillRoundRect(x, y, buttonSize, buttonSize, 5, 5);
        
        // Draw pause icon
        gc.setFill(Color.WHITE);
        gc.fillRect(x + buttonSize * 0.3, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        gc.fillRect(x + buttonSize * 0.55, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        
        // Draw button border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(x, y, buttonSize, buttonSize, 5, 5);
    }
    
    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            gc.setFill(Color.BLACK);
            gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
            return;
        }
        
        System.out.println("Drawing background for room type: " + currentRoom.getType());
        
        // Set the base background color based on room type
        Color baseColor;
        switch (currentRoom.getType()) {
            case SPAWN:
                baseColor = Color.rgb(0, 80, 0); // Dark green for spawn
                break;
            case COMBAT:
                baseColor = Color.rgb(70, 30, 30); // Dark red for combat
                break;
            case PUZZLE:
                baseColor = Color.rgb(30, 30, 80); // Dark blue for puzzle
                break;
            case TREASURE:
                baseColor = Color.rgb(80, 80, 30); // Gold for treasure
                break;
            case BOSS:
                baseColor = Color.rgb(80, 0, 0); // Deep red for boss
                break;
            default:
                baseColor = Color.rgb(30, 30, 30); // Dark gray default
                break;
        }
        
        // Fill the entire canvas with the base color
        gc.setFill(baseColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw floor tiles based on room type
        double tileSize = 40;
        
        switch (currentRoom.getType()) {
            case COMBAT:
                drawCombatRoomFloor(gc, tileSize);
                break;
            case PUZZLE:
                drawPuzzleRoomFloor(gc, tileSize);
                break;
            case TREASURE:
                drawTreasureRoomFloor(gc, tileSize);
                break;
            case BOSS:
                drawBossRoomFloor(gc, tileSize);
                break;
            case SPAWN:
            default:
                drawSpawnRoomFloor(gc, tileSize);
                break;
        }
        
        // Draw room borders
        gc.setStroke(Color.DARKGRAY);
        gc.setLineWidth(5);
        gc.strokeRect(10, 10, gameCanvas.getWidth() - 20, gameCanvas.getHeight() - 20);
    }
    
    private void drawCombatRoomFloor(GraphicsContext gc, double tileSize) {
        // Checkered pattern in dark red
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(60, 20, 20));
                } else {
                    gc.setFill(Color.rgb(40, 10, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add some blood stains
        gc.setFill(Color.rgb(120, 0, 0, 0.3));
        for (int i = 0; i < 10; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 20 + random.nextDouble() * 30;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawPuzzleRoomFloor(GraphicsContext gc, double tileSize) {
        // Blue tiled pattern with symbols
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(20, 30, 50));
                gc.fillRect(x, y, tileSize, tileSize);
                
                // Add tile borders
                gc.setStroke(Color.rgb(30, 40, 70));
                gc.strokeRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add arcane symbols
        gc.setFill(Color.rgb(100, 150, 255, 0.2));
        for (int i = 0; i < 8; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 30 + random.nextDouble() * 40;
            
            // Draw a random arcane symbol (simplified)
            double angle = random.nextDouble() * Math.PI * 2;
            double[] xPoints = new double[5];
            double[] yPoints = new double[5];
            
            for (int j = 0; j < 5; j++) {
                xPoints[j] = x + Math.cos(angle + j * Math.PI * 2 / 5) * size / 2;
                yPoints[j] = y + Math.sin(angle + j * Math.PI * 2 / 5) * size / 2;
            }
            
            gc.fillPolygon(xPoints, yPoints, 5);
        }
    }
    
    private void drawTreasureRoomFloor(GraphicsContext gc, double tileSize) {
        // Gold/yellow tiled pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(80, 70, 20));
                } else {
                    gc.setFill(Color.rgb(60, 50, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add gold coins scattered around
        gc.setFill(Color.GOLD);
        for (int i = 0; i < 30; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 3 + random.nextDouble() * 5;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawBossRoomFloor(GraphicsContext gc, double tileSize) {
        // Dark pattern with lava cracks
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(30, 10, 10));
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add lava cracks
        gc.setFill(Color.rgb(255, 50, 0, 0.7));
        for (int i = 0; i < 15; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double width = 5 + random.nextDouble() * 100;
            double height = 3 + random.nextDouble() * 5;
            double angle = random.nextDouble() * Math.PI;
            
            gc.save();
            gc.translate(x, y);
            gc.rotate(Math.toDegrees(angle));
            gc.fillRect(-width/2, -height/2, width, height);
            gc.restore();
        }
    }
    
    private void drawSpawnRoomFloor(GraphicsContext gc, double tileSize) {
        // Green/brown natural pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(30, 50, 30));
                } else {
                    gc.setFill(Color.rgb(40, 60, 40));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
    }
    
    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Clear previous lights
        lightingEffect.clearLights();
        
        // Set ambient light based on room type
        switch (currentRoom.getType()) {
            case COMBAT:
                lightingEffect.setAmbientLight(0.3); // Dim red lighting
                break;
                
            case PUZZLE:
                lightingEffect.setAmbientLight(0.4); // Moderate blue lighting
                break;
                
            case TREASURE:
                lightingEffect.setAmbientLight(0.5); // Brighter gold lighting
                break;
                
            case BOSS:
                lightingEffect.setAmbientLight(0.2); // Very dark with red tint
                break;
                
            case SPAWN:
            default:
                lightingEffect.setAmbientLight(0.6); // Bright natural lighting
                break;
        }
        
        // Add player light
        lightingEffect.addLightSource(
            player.getPosition(), 
            150, 
            Color.WHITE, 
            LightingEffect.LightSource.LightType.FLICKERING
        );
        
        // Add door lights
        for (Door door : doors) {
            Color lightColor = door.isLocked() ? Color.RED : Color.GREEN;
            lightingEffect.addLightSource(
                new Point2D(door.getX() + door.getWidth()/2, door.getY() + door.getHeight()/2),
                60,
                lightColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add item lights
        for (Item item : roomItems) {
            Color itemColor = getItemColor(item.getType());
            lightingEffect.addLightSource(
                new Point2D(item.getX(), item.getY()),
                item.getSize() * 3,
                itemColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add enemy lights
        for (Enemy enemy : enemies) {
            Color enemyColor = Color.RED;
            if (enemy.getType() == Enemy.EnemyType.BOSS) {
                enemyColor = Color.DARKRED;
            } else if (enemy.getType() == Enemy.EnemyType.MAGE) {
                enemyColor = Color.BLUE;
            }
            
            lightingEffect.addLightSource(
                enemy.getPosition(),
                enemy.getSize() * 2,
                enemyColor,
                enemy.getType() == Enemy.EnemyType.BOSS ? 
                    LightingEffect.LightSource.LightType.PULSING : 
                    LightingEffect.LightSource.LightType.FLICKERING
            );
        }
        
        // Add environmental lights based on room type
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
            // Add lava lights for boss room
            for (int i = 0; i < 5; i++) {
                double x = random.nextDouble() * gameCanvas.getWidth();
                double y = random.nextDouble() * gameCanvas.getHeight();
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    30 + random.nextDouble() * 50,
                    Color.ORANGE,
                    LightingEffect.LightSource.LightType.FLICKERING
                );
            }
        } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            // Add arcane lights for puzzle room
            for (int i = 0; i < 4; i++) {
                double x = 100 + i * (gameCanvas.getWidth() - 200) / 3;
                double y = gameCanvas.getHeight() / 2;
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    70,
                    Color.CYAN,
                    LightingEffect.LightSource.LightType.PULSING
                );
            }
        }
    }
    
    private void renderUI(GraphicsContext gc) {
        if (player == null) return;
        
        // Set up fonts
        Font titleFont = Font.font("Arial", FontWeight.BOLD, 16);
        Font normalFont = Font.font("Arial", FontWeight.NORMAL, 14);
        
        // Draw player health bar
        double healthBarWidth = 200;
        double healthBarHeight = 20;
        double healthPercentage = (double) player.getHealth() / player.getMaxHealth();
        
        // Health bar background
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health bar fill
        Color healthColor;
        if (healthPercentage > 0.7) {
            healthColor = Color.GREEN;
        } else if (healthPercentage > 0.3) {
            healthColor = Color.YELLOW;
        } else {
            healthColor = Color.RED;
        }
        
        gc.setFill(healthColor);
        gc.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
        
        // Health bar border
        gc.setStroke(Color.BLACK);
        gc.setLineWidth(2);
        gc.strokeRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health text
        gc.setFill(Color.WHITE);
        gc.setFont(normalFont);
        gc.fillText("HP: " + (int)player.getHealth() + "/" + (int)player.getMaxHealth(), 
                    25, 36);
        
        // Draw current weapon info
        String weaponText = "Weapon: " + player.getCurrentWeapon().getType().getName();
        gc.fillText(weaponText, 20, 60);
        
        // Draw score
        gc.setFont(normalFont);
        gc.fillText("Score: " + player.getScore(), 20, 80);
        
        // Draw enemy count
        gc.fillText("Enemies: " + enemies.size(), 20, 100);
        
        // Draw level info
        gc.fillText("Level: " + currentLevel, 20, 120);
        
        // Draw current room type
        String roomTypeText = "Room: " + (currentRoom != null ? currentRoom.getType().toString() : "UNKNOWN");
        gc.fillText(roomTypeText, 20, 140);
        
        // Draw mini-map in top-right corner if needed
        if (isDebugMode) {
            drawMiniMap(gc);
        }
        
        // Draw FPS counter in debug mode
        if (isDebugMode) {
            long currentTime = System.nanoTime();
            double fps = 1_000_000_000.0 / (currentTime - lastUpdateTime);
            gc.fillText(String.format("FPS: %.1f", fps), gameCanvas.getWidth() - 100, 20);
        }
        
        // Controls reminder at the bottom
        gc.setFill(Color.LIGHTBLUE);
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                   gameCanvas.getWidth() / 2 - 200, gameCanvas.getHeight() - 20);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        double cellSize = 10;
        
        // Draw mini-map background
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw mini-map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Find min/max coordinates to center the map
        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
        
        for (DungeonRoom room : currentDungeon) {
            minX = Math.min(minX, room.getX());
            minY = Math.min(minY, room.getY());
            maxX = Math.max(maxX, room.getX());
            maxY = Math.max(maxY, room.getY());
        }
        
        // Calculate scaling to fit all rooms
        int mapWidth = maxX - minX + 1;
        int mapHeight = maxY - minY + 1;
        double scaleX = mapSize / (mapWidth * 1.5);
        double scaleY = mapSize / (mapHeight * 1.5);
        double scale = Math.min(scaleX, scaleY);
        
        // Calculate offset to center the map
        double offsetX = mapX + (mapSize - mapWidth * scale) / 2;
        double offsetY = mapY + (mapSize - mapHeight * scale) / 2;
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = offsetX + (room.getX() - minX) * scale;
            double roomY = offsetY + (room.getY() - minY) * scale;
            
            // Choose color based on room type
            Color roomColor;
            switch (room.getType()) {
                case SPAWN:
                    roomColor = Color.GREEN;
                    break;
                case BOSS:
                    roomColor = Color.RED;
                    break;
                case PUZZLE:
                    roomColor = Color.BLUE;
                    break;
                case TREASURE:
                    roomColor = Color.GOLD;
                    break;
                default:
                    roomColor = Color.GRAY;
            }
            
            // Draw room
            gc.setFill(room.isVisited() ? roomColor : Color.DARKGRAY);
            gc.fillRect(roomX, roomY, scale * 0.8, scale * 0.8);
            
            // If this is the current room, highlight it
            if (room == currentRoom) {
                gc.setStroke(Color.WHITE);
                gc.setLineWidth(2);
                gc.strokeRect(roomX, roomY, scale * 0.8, scale * 0.8);
            }
        }
        
        // Draw minimap legend
        double legendX = mapX + 10;
        double legendY = mapY + mapSize + 10;
        double legendBoxSize = 8;
        double textOffset = 15;
        
        gc.setFont(Font.font("Arial", FontWeight.NORMAL, 10));
        
        // Current room
        gc.setFill(Color.WHITE);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.fillText("Current", legendX + legendBoxSize + 5, legendY + 8);
        
        // Spawn room
        legendY += textOffset;
        gc.setFill(Color.GREEN);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Spawn", legendX + legendBoxSize + 5, legendY + 8);
        
        // Boss room
        legendY += textOffset;
        gc.setFill(Color.RED);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Boss", legendX + legendBoxSize + 5, legendY + 8);
        
        // Unvisited room
        legendY += textOffset;
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Unexplored", legendX + legendBoxSize + 5, legendY + 8);
    }

    public Player getPlayer() {
        return player;
    }

    private Color getItemColor(Item.ItemType type) {
        switch (type) {
            case WEAPON: return Color.RED;
            case POTION: return Color.GREEN;
            case ARMOR: return Color.BLUE;
            default: return Color.WHITE;
        }
    }

    private void createDoors() {
        // First remove existing doors
        doors.clear();
        
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors for null room");
            return;
        }
        
        System.out.println("Creating doors for room " + currentRoom.getType() + 
                          " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")");
        
        List<DungeonRoom> connectedRooms = currentRoom.getConnectedRooms();
        System.out.println("Connected rooms: " + connectedRooms.size());
        
        if (connectedRooms.isEmpty()) {
            System.err.println("WARNING: Room has no connected rooms!");
            return;
        }
        
        // Determine room bounds on the canvas
        double roomWidth = gameCanvas.getWidth() - 100;  // 50px margin on each side
        double roomHeight = gameCanvas.getHeight() - 100;
        double doorWidth = DOOR_WIDTH;
        double doorHeight = DOOR_HEIGHT;
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : connectedRooms) {
            if (connectedRoom == null) {
                System.err.println("WARNING: Connected room is null!");
                continue;
            }
            
            // Determine direction to the connected room
            int dx = connectedRoom.getX() - currentRoom.getX();
            int dy = connectedRoom.getY() - currentRoom.getY();
            
            System.out.println("Adding door to " + connectedRoom.getType() + 
                              " at direction (" + dx + "," + dy + ")");
            
            // Calculate door position based on direction
            double doorX, doorY;
            Door.DoorDirection doorDirection;
            
            if (dx > 0) {      // East door
                doorX = roomWidth - doorWidth + 50;
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.EAST;
            } else if (dx < 0) { // West door
                doorX = 50;  // Left margin
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.WEST;
            } else if (dy > 0) { // South door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = roomHeight - doorHeight + 50;
                doorDirection = Door.DoorDirection.SOUTH;
            } else {            // North door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = 50;  // Top margin
                doorDirection = Door.DoorDirection.NORTH;
            }
            
            // Create the door
            Door door = new Door(
                doorX, doorY, doorWidth, doorHeight,
                currentRoom, connectedRoom, doorDirection
            );
            
            // Lock doors based on room type
            if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT ||
                currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                // Combat rooms: doors are locked until enemies are defeated
                door.setLocked(!enemies.isEmpty());
                System.out.println("Combat/Boss room door locked state: " + door.isLocked() + 
                                 " (enemies: " + enemies.size() + ")");
            } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Puzzle rooms: doors are locked until puzzle is solved
                door.setLocked(!puzzleCompleted);
                door.setRequiresKey(true);
                System.out.println("Puzzle room door locked state: " + door.isLocked() + 
                                 " (puzzle completed: " + puzzleCompleted + ")");
            }
            
            doors.add(door);
            System.out.println("Added door at " + doorX + "," + doorY + 
                              " to " + connectedRoom.getType() + 
                              " (locked: " + door.isLocked() + ", requires key: " + door.requiresKey() + ")");
        }
        
        // Debug output of created doors
        if (doors.isEmpty()) {
            System.err.println("WARNING: No doors were created!");
        } else {
            System.out.println("Created " + doors.size() + " doors");
        }
    }
    
    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        roomCleared = false;
        
        System.out.println("Populating room of type: " + room.getType() + " at position " + room.getX() + "," + room.getY());
        
        // Get room center
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        Point2D roomCenter = new Point2D(centerX, centerY);
        
        switch (room.getType()) {
            case COMBAT:
                // Add enemies in combat rooms
                spawnEnemiesForRoom(room, false);
                
                // Add a health potion
                if (new Random().nextDouble() < 0.5) {
                    spawnBasicItem(roomCenter.add(50, 50));
                    System.out.println("Added health potion to combat room");
                }
                break;
                
            case BOSS:
                // Add boss enemy with enhanced spawning
                spawnEnemiesForRoom(room, true);
                break;
                
            case TREASURE:
                // Add random items
                System.out.println("Spawning items in treasure room");
                Random rnd = new Random();
                int itemCount = 2 + rnd.nextInt(3); // 2-4 items
                
                for (int i = 0; i < itemCount; i++) {
                    double angle = rnd.nextDouble() * Math.PI * 2; // Random angle
                    double distance = 50 + rnd.nextDouble() * 100; // Distance from center
                    
                    double offsetX = Math.cos(angle) * distance;
                    double offsetY = Math.sin(angle) * distance;
                    
                    spawnBasicItem(roomCenter.add(offsetX, offsetY));
                }
                break;
                
            case PUZZLE:
                // Add a key
                System.out.println("Adding key to puzzle room");
                placeKeyInRoom(room);
                break;
                
            case SPAWN:
            default:
                // No special spawns in spawn room
                break;
        }
        
        // Create doors for the new room
        createDoors();
    }
    
    /**
     * Enhanced enemy spawning system for rooms
     */
    private void spawnEnemiesForRoom(DungeonRoom room, boolean isBossRoom) {
        Random random = new Random();
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        if (isBossRoom) {
            System.out.println("Spawning boss in boss room");
            // Create a boss enemy
            Enemy bossEnemy = new Enemy(centerX, centerY, Enemy.EnemyType.BOSS);
            
            // Double the boss's max health and increase damage
            bossEnemy.setMaxHealth(bossEnemy.getMaxHealth() * 2);
            bossEnemy.heal(bossEnemy.getMaxHealth()); // Heal to full health
            
            // Add the boss
            enemies.add(bossEnemy);
            
            // Add minions around the boss
            int minionCount = 1 + random.nextInt(2); // 1-2 minions
            for (int i = 0; i < minionCount; i++) {
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 120 + random.nextInt(50);
                
                double enemyX = centerX + Math.cos(angle) * distance;
                double enemyY = centerY + Math.sin(angle) * distance;
                
                // Keep within bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Create a minion (using the constructor with behavior parameter)
                Enemy minion = new Enemy(enemyX, enemyY, Enemy.EnemyType.SKELETON, Enemy.BehaviorType.AGGRESSIVE, 1);
                enemies.add(minion);
            }
            
            System.out.println("Spawned boss with " + minionCount + " minions");
        } else {
            // Regular combat room
            int playerLevel = player != null ? player.getLevel() : 1;
            int roomDepth = Math.abs(room.getX()) + Math.abs(room.getY());
            
            // Adjust enemy count based on player level and room distance from spawn
            int baseEnemyCount = 2;
            int levelBonus = (playerLevel - 1) / 2; // Every 2 levels adds an enemy
            int depthBonus = roomDepth / 3; // Every 3 rooms deeper adds an enemy
            int maxEnemyCount = Math.min(6, baseEnemyCount + levelBonus + depthBonus);
            int enemyCount = baseEnemyCount + random.nextInt(maxEnemyCount - baseEnemyCount + 1);
            
            System.out.println("Spawning " + enemyCount + " enemies in combat room (player level: " + 
                              playerLevel + ", room depth: " + roomDepth + ")");
            
            // Determine possible enemy types based on depth
            List<Enemy.EnemyType> possibleTypes = new ArrayList<>();
            possibleTypes.add(Enemy.EnemyType.GOBLIN);  // Always available
            
            if (roomDepth > 1 || playerLevel > 1) {
                possibleTypes.add(Enemy.EnemyType.SKELETON);
            }
            
            if (roomDepth > 3 || playerLevel > 3) {
                possibleTypes.add(Enemy.EnemyType.ORC);
            }
            
            if (roomDepth > 5 || playerLevel > 5) {
                possibleTypes.add(Enemy.EnemyType.MAGE);
            }
            
            // Spawn enemies
            for (int i = 0; i < enemyCount; i++) {
                // Calculate random position within the room, away from center
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 100 + random.nextDouble() * 150;
                
                double offsetX = Math.cos(angle) * distance;
                double offsetY = Math.sin(angle) * distance;
                
                double enemyX = centerX + offsetX;
                double enemyY = centerY + offsetY;
                
                // Keep enemies within room bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Randomly select an enemy type from the available options
                Enemy.EnemyType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                
                // Determine behavior type
                Enemy.BehaviorType behaviorType;
                double behaviorRand = random.nextDouble();
                if (behaviorRand < 0.6) {
                    behaviorType = Enemy.BehaviorType.AGGRESSIVE;
                } else if (behaviorRand < 0.8) {
                    behaviorType = Enemy.BehaviorType.RANGED;
                } else if (behaviorRand < 0.9) {
                    behaviorType = Enemy.BehaviorType.PATROLLER;
                } else {
                    behaviorType = Enemy.BehaviorType.AMBUSHER;
                }
                
                // Create enemy with the determined behavior type
                Enemy enemy = new Enemy(enemyX, enemyY, type, behaviorType, 1);
                
                // Scale enemy based on room depth and player level
                if (roomDepth > 2 || playerLevel > 2) {
                    double healthMultiplier = 1.0 + (roomDepth * 0.1) + ((playerLevel - 1) * 0.05);
                    enemy.setMaxHealth(enemy.getMaxHealth() * healthMultiplier);
                    enemy.heal(enemy.getMaxHealth()); // Set to full health
                }
                
                enemies.add(enemy);
                System.out.println("Added enemy at " + enemyX + "," + enemyY + " of type: " + type + 
                                  ", behavior: " + enemy.getBehavior());
            }
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Determine number of items based on room type
        switch (room.getType()) {
            case COMBAT:
                itemCount = random.nextInt(2); // 0-1 items
                break;
            case PUZZLE:
                itemCount = 1; // Always spawn a key
                // Add a key to unlock doors
                placeKeyInRoom(room);
                break;
            case TREASURE:
                itemCount = random.nextInt(3) + 2; // 2-4 items
                break;
            case BOSS:
                itemCount = random.nextInt(2) + 1; // 1-2 special items
                break;
            case SPAWN:
                // No items in spawn room
                return;
        }
        
        // Add random items
        for (int i = 0; i < itemCount; i++) {
            addItemToRoom(room);
        }
    }
    
    private void placeKeyInRoom(DungeonRoom room) {
        // Get the center of the room on the canvas
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        // Add some randomness to key position
        Random random = new Random();
        double keyX = centerX + (random.nextDouble() - 0.5) * 100;
        double keyY = centerY + (random.nextDouble() - 0.5) * 100;
        
        // Create and add the key
        Item roomKey = new Item("Room Key", "Opens locked doors", Item.ItemType.KEY, 1, true);
        roomKey.setX(keyX);
        roomKey.setY(keyY);
        roomKey.setSize(20);
        
        System.out.println("Added key at position: " + keyX + "," + keyY);
        roomItems.add(roomKey);
    }
    
    private void spawnBasicItem(Point2D position) {
        Random random = new Random();
        
        // Randomize item type
        Item.ItemType type;
        String name;
        String description;
        int value;
        boolean consumable;
        
        double rnd = random.nextDouble();
        if (rnd < 0.6) {
            // 60% chance for a potion
            type = Item.ItemType.POTION;
            name = "Health Potion";
            description = "Restores 20 health";
            value = 20;
            consumable = true;
        } else if (rnd < 0.8) {
            // 20% chance for a weapon
            type = Item.ItemType.WEAPON;
            name = "Sword";
            description = "A sharp weapon";
            value = 15;
            consumable = false;
        } else {
            // 20% chance for treasure
            type = Item.ItemType.TREASURE;
            name = "Gold Coins";
            description = "Valuable treasure";
            value = 50;
            consumable = true;
        }
        
        // Create the item
        Item item = new Item(name, description, type, value, consumable);
        item.setX(position.getX());
        item.setY(position.getY());
        item.setSize(20);
        
        System.out.println("Added item: " + name + " at " + position.getX() + "," + position.getY());
        
        roomItems.add(item);
    }
    
    private void spawnEnemy(DungeonRoom room) {
        Random random = new Random();
        Point2D roomPos = new Point2D(room.getX(), room.getY());
        Point2D randomOffset = new Point2D(
            random.nextDouble() * room.getWidth(),
            random.nextDouble() * room.getHeight()
        );
        Point2D spawnPos = roomPos.add(randomOffset).multiply(8); // Scale to pixel coordinates
        
        Enemy.EnemyType type = random.nextBoolean() ? Enemy.EnemyType.GOBLIN : Enemy.EnemyType.SKELETON;
        enemies.add(new Enemy(spawnPos.getX(), spawnPos.getY(), type));
    }

    private boolean isColliding(Entity entity1, Entity entity2) {
        Point2D center1 = entity1.getPosition().add(entity1.getSize() / 2, entity1.getSize() / 2);
        Point2D center2 = entity2.getPosition().add(entity2.getSize() / 2, entity2.getSize() / 2);
        double distance = center1.distance(center2);
        double combinedRadius = (entity1.getSize() + entity2.getSize()) / 2;
        return distance < combinedRadius;
    }

    private boolean isInMeleeRange(Entity attacker, Entity target) {
        double attackRange = 40; // Melee attack range
        
        Point2D attackerCenter = attacker.getPosition().add(new Point2D(attacker.getSize() / 2, attacker.getSize() / 2));
        Point2D targetCenter = target.getPosition().add(new Point2D(target.getSize() / 2, target.getSize() / 2));
        
        return attackerCenter.distance(targetCenter) < (attacker.getSize() / 2 + target.getSize() / 2 + attackRange);
    }

    private void showFloatingText(String text, Point2D position) {
        // This would be implemented with a UI element that floats up and fades out
        // For now, we'll just print to console
        System.out.println("Floating text at " + position + ": " + text);
    }

    private void dropRandomItem(Point2D position) {
        Random random = new Random();
        if (random.nextDouble() < 0.3) { // 30% chance to drop an item
            Item.ItemType type = Item.ItemType.values()[random.nextInt(Item.ItemType.values().length)];
            String name;
            String description;
            int value;
            boolean consumable;
            
            switch (type) {
                case WEAPON:
                    name = "Sword";
                    description = "A sharp blade";
                    value = 10;
                    consumable = false;
                    break;
                case POTION:
                    name = "Health Potion";
                    description = "Restores 20 HP";
                    value = 20;
                    consumable = true;
                    break;
                case ARMOR:
                    name = "Shield";
                    description = "Provides protection";
                    value = 15;
                    consumable = false;
                    break;
                default:
                    name = "Gold Coins";
                    description = "Valuable treasure";
                    value = 50;
                    consumable = true;
                    type = Item.ItemType.TREASURE;
                    break;
            }
            
            // Create and add the item
            Item item = new Item(name, description, type, value, consumable);
            item.setX(position.getX());
            item.setY(position.getY());
            item.setSize(20);
            roomItems.add(item);
        }
    }

    private boolean isPlayerTouchingItem(Item item) {
        double playerCenterX = player.getPosition().getX() + player.getSize() / 2;
        double playerCenterY = player.getPosition().getY() + player.getSize() / 2;
        double itemCenterX = item.getX() + 5; // Assuming item size is 10x10
        double itemCenterY = item.getY() + 5;
        
        double distance = Math.sqrt(
            Math.pow(playerCenterX - itemCenterX, 2) + 
            Math.pow(playerCenterY - itemCenterY, 2)
        );
        
        return distance < (player.getSize() / 2 + 5); // Player radius + item radius
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                System.out.println("Player touching door to " + door.getConnectedRoom().getType() + 
                                  " - Door locked: " + door.isLocked() + 
                                  ", Requires key: " + door.requiresKey());
                
                if (!door.isLocked()) {
                    // Get the connected room
                    DungeonRoom targetRoom = door.getConnectedRoom();
                    if (targetRoom != null) {
                        System.out.println("Door unlocked - transitioning to room: " + targetRoom.getType() + 
                                          " at position " + targetRoom.getX() + "," + targetRoom.getY());
                        
                        // Calculate entry position based on door direction
                        Point2D entryPosition = getEntryPosition(door);
                        
                        // Pass target room and entry position to transition method
                        transitionToRoom(targetRoom, entryPosition);
                        
                        // Update difficulty based on room type if it's a boss room
                        if (targetRoom.getType() == DungeonRoom.RoomType.BOSS) {
                            adjustDifficultyForLevel();
                        }
                        
                        break;
                    } else {
                        System.err.println("ERROR: Connected room is null!");
                    }
                } else {
                    // Show message about locked door if player is touching it
                    if (door.requiresKey()) {
                        effectsManager.showFloatingText("This door requires a key", 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.YELLOW);
                        
                        // Try to unlock with key if player has one
                        if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                            if (door.unlock(player.getInventory())) {
                                effectsManager.showFloatingText("Door unlocked!", 
                                    new Point2D(door.getX() + door.getWidth()/2, door.getY() - 10),
                                    Color.GREEN);
                                // Door is now unlocked, but wait for next check to transition
                            }
                        }
                    } else {
                        // Door is locked for other reasons (enemies not defeated)
                        String message = "Defeat all enemies to unlock";
                        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                            message = "Solve the puzzle to unlock";
                        }
                        effectsManager.showFloatingText(message, 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.RED);
                    }
                }
            }
        }
    }

    private void transitionToRoom(DungeonRoom room) {
        if (roomTransitionInProgress || room == null) {
            System.out.println("Cannot transition to room: " + (room == null ? "null" : room.getType()) + 
                               ", transition in progress: " + roomTransitionInProgress);
            return;
        }
        
        System.out.println("Starting transition to " + room.getType() + " room at position " + room.getX() + "," + room.getY());
        roomTransitionInProgress = true;
        
        // Create a fade transition effect
        Rectangle fadeRect = new Rectangle(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        fadeRect.setFill(Color.BLACK);
        fadeRect.setOpacity(0);
        rootPane.getChildren().add(fadeRect);
        
        // Create fade out transition
        javafx.animation.FadeTransition fadeOut = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeOut.setFromValue(0);
        fadeOut.setToValue(1);
        
        // Create fade in transition
        javafx.animation.FadeTransition fadeIn = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeIn.setFromValue(1);
        fadeIn.setToValue(0);
        
        // Add visual effects for room transition
        effectsManager.addRoomTransitionEffect();
        
        // Set up the sequence
        fadeOut.setOnFinished(e -> {
            // Change room
            currentRoom = room;
            currentRoom.setVisited(true);
            
            // Reset player position to center of new room
            double roomCenterX = currentRoom.getX() + currentRoom.getWidth() / 2 - player.getSize() / 2;
            double roomCenterY = currentRoom.getY() + currentRoom.getHeight() / 2 - player.getSize() / 2;
            player.setPosition(new Point2D(roomCenterX, roomCenterY));
            
            // Clear enemies and items from previous room
            enemies.clear();
            projectiles.clear();
            roomItems.clear();
            doors.clear();
            
            // Populate new room
            populateRoom(currentRoom);
            
            // Create doors for the new room
            createDoors();
            
            // Update minimap
            updateMinimap();
        });
        
        fadeIn.setOnFinished(e -> {
            // Remove the fade rectangle
            rootPane.getChildren().remove(fadeRect);
            roomTransitionInProgress = false;
            
            // Display room entrance message
            String roomTypeText = "";
            switch (currentRoom.getType()) {
                case COMBAT:
                    roomTypeText = "Combat Room";
                    break;
                case PUZZLE:
                    roomTypeText = "Puzzle Room";
                    break;
                case TREASURE:
                    roomTypeText = "Treasure Room";
                    break;
                case BOSS:
                    roomTypeText = "Boss Room";
                    break;
                case SPAWN:
                    roomTypeText = "Starting Room";
                    break;
            }
            
            // Show floating text for room type
            showFloatingText("Entered: " + roomTypeText, 
                new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4));
                
            // Initialize room-specific lighting
            updateLighting();
        });
        
        // Start the transition
        fadeOut.play();
    }
    
    private void handleDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item name for debug or when player is close
            if (isDebugMode || (player != null && 
                player.getPosition().distance(new Point2D(item.getX(), item.getY())) < 100)) {
                gc.setFill(Color.WHITE);
                gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                gc.fillText(item.getName(), item.getX() - 20, item.getY() - 10);
            }
        }
        
        // Draw enemies
        if (enemies.isEmpty()) {
            System.out.println("No enemies to render in current room");
        } else {
            System.out.println("Rendering " + enemies.size() + " enemies");
            for (Enemy enemy : enemies) {
                System.out.println("Rendering enemy at: " + enemy.getX() + "," + enemy.getY() + " of type: " + enemy.getType());
                // Draw enemy as a red rectangle
                if (enemy.getType() == Enemy.EnemyType.BOSS) {
                    gc.setFill(Color.DARKRED);
                    // Draw boss larger
                    gc.fillRect(enemy.getX() - 5, enemy.getY() - 5, enemy.getSize() + 10, enemy.getSize() + 10);
                } else {
                    gc.setFill(Color.RED);
                    gc.fillRect(enemy.getX(), enemy.getY(), enemy.getSize(), enemy.getSize());
                }
                
                // Draw enemy health bar
                double healthPercentage = (double) enemy.getHealth() / enemy.getMaxHealth();
                double healthBarWidth = enemy.getSize() * healthPercentage;
                
                gc.setFill(Color.BLACK);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, enemy.getSize(), 5);
                gc.setFill(Color.GREEN);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, healthBarWidth, 5);
                
                // Draw enemy type if debug mode is on
                if (isDebugMode) {
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(enemy.getType().toString(), enemy.getX(), enemy.getY() - 12);
                }
            }
        }
        
        // Draw player projectiles
        for (ProjectileAttack attack : playerProjectiles) {
            attack.render(gc);
        }
        
        // Draw projectiles
        for (Projectile projectile : projectiles) {
            projectile.render(gc);
        }
        
        // Draw the player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw UI elements
        renderUI(gc);
    }
    
    private void drawPauseButton(GraphicsContext gc) {
        // Draw pause button in top-right corner
        double buttonSize = 30;
        double padding = 10;
        double x = gameCanvas.getWidth() - buttonSize - padding;
        double y = padding;
        
        // Draw button background
        gc.setFill(Color.DARKGRAY);
        gc.fillRoundRect(x, y, buttonSize, buttonSize, 5, 5);
        
        // Draw pause icon
        gc.setFill(Color.WHITE);
        gc.fillRect(x + buttonSize * 0.3, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        gc.fillRect(x + buttonSize * 0.55, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        
        // Draw button border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(x, y, buttonSize, buttonSize, 5, 5);
    }
    
    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            gc.setFill(Color.BLACK);
            gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
            return;
        }
        
        System.out.println("Drawing background for room type: " + currentRoom.getType());
        
        // Set the base background color based on room type
        Color baseColor;
        switch (currentRoom.getType()) {
            case SPAWN:
                baseColor = Color.rgb(0, 80, 0); // Dark green for spawn
                break;
            case COMBAT:
                baseColor = Color.rgb(70, 30, 30); // Dark red for combat
                break;
            case PUZZLE:
                baseColor = Color.rgb(30, 30, 80); // Dark blue for puzzle
                break;
            case TREASURE:
                baseColor = Color.rgb(80, 80, 30); // Gold for treasure
                break;
            case BOSS:
                baseColor = Color.rgb(80, 0, 0); // Deep red for boss
                break;
            default:
                baseColor = Color.rgb(30, 30, 30); // Dark gray default
                break;
        }
        
        // Fill the entire canvas with the base color
        gc.setFill(baseColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw floor tiles based on room type
        double tileSize = 40;
        
        switch (currentRoom.getType()) {
            case COMBAT:
                drawCombatRoomFloor(gc, tileSize);
                break;
            case PUZZLE:
                drawPuzzleRoomFloor(gc, tileSize);
                break;
            case TREASURE:
                drawTreasureRoomFloor(gc, tileSize);
                break;
            case BOSS:
                drawBossRoomFloor(gc, tileSize);
                break;
            case SPAWN:
            default:
                drawSpawnRoomFloor(gc, tileSize);
                break;
        }
        
        // Draw room borders
        gc.setStroke(Color.DARKGRAY);
        gc.setLineWidth(5);
        gc.strokeRect(10, 10, gameCanvas.getWidth() - 20, gameCanvas.getHeight() - 20);
    }
    
    private void drawCombatRoomFloor(GraphicsContext gc, double tileSize) {
        // Checkered pattern in dark red
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(60, 20, 20));
                } else {
                    gc.setFill(Color.rgb(40, 10, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add some blood stains
        gc.setFill(Color.rgb(120, 0, 0, 0.3));
        for (int i = 0; i < 10; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 20 + random.nextDouble() * 30;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawPuzzleRoomFloor(GraphicsContext gc, double tileSize) {
        // Blue tiled pattern with symbols
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(20, 30, 50));
                gc.fillRect(x, y, tileSize, tileSize);
                
                // Add tile borders
                gc.setStroke(Color.rgb(30, 40, 70));
                gc.strokeRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add arcane symbols
        gc.setFill(Color.rgb(100, 150, 255, 0.2));
        for (int i = 0; i < 8; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 30 + random.nextDouble() * 40;
            
            // Draw a random arcane symbol (simplified)
            double angle = random.nextDouble() * Math.PI * 2;
            double[] xPoints = new double[5];
            double[] yPoints = new double[5];
            
            for (int j = 0; j < 5; j++) {
                xPoints[j] = x + Math.cos(angle + j * Math.PI * 2 / 5) * size / 2;
                yPoints[j] = y + Math.sin(angle + j * Math.PI * 2 / 5) * size / 2;
            }
            
            gc.fillPolygon(xPoints, yPoints, 5);
        }
    }
    
    private void drawTreasureRoomFloor(GraphicsContext gc, double tileSize) {
        // Gold/yellow tiled pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(80, 70, 20));
                } else {
                    gc.setFill(Color.rgb(60, 50, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add gold coins scattered around
        gc.setFill(Color.GOLD);
        for (int i = 0; i < 30; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 3 + random.nextDouble() * 5;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawBossRoomFloor(GraphicsContext gc, double tileSize) {
        // Dark pattern with lava cracks
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(30, 10, 10));
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add lava cracks
        gc.setFill(Color.rgb(255, 50, 0, 0.7));
        for (int i = 0; i < 15; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double width = 5 + random.nextDouble() * 100;
            double height = 3 + random.nextDouble() * 5;
            double angle = random.nextDouble() * Math.PI;
            
            gc.save();
            gc.translate(x, y);
            gc.rotate(Math.toDegrees(angle));
            gc.fillRect(-width/2, -height/2, width, height);
            gc.restore();
        }
    }
    
    private void drawSpawnRoomFloor(GraphicsContext gc, double tileSize) {
        // Green/brown natural pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(30, 50, 30));
                } else {
                    gc.setFill(Color.rgb(40, 60, 40));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
    }
    
    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Clear previous lights
        lightingEffect.clearLights();
        
        // Set ambient light based on room type
        switch (currentRoom.getType()) {
            case COMBAT:
                lightingEffect.setAmbientLight(0.3); // Dim red lighting
                break;
                
            case PUZZLE:
                lightingEffect.setAmbientLight(0.4); // Moderate blue lighting
                break;
                
            case TREASURE:
                lightingEffect.setAmbientLight(0.5); // Brighter gold lighting
                break;
                
            case BOSS:
                lightingEffect.setAmbientLight(0.2); // Very dark with red tint
                break;
                
            case SPAWN:
            default:
                lightingEffect.setAmbientLight(0.6); // Bright natural lighting
                break;
        }
        
        // Add player light
        lightingEffect.addLightSource(
            player.getPosition(), 
            150, 
            Color.WHITE, 
            LightingEffect.LightSource.LightType.FLICKERING
        );
        
        // Add door lights
        for (Door door : doors) {
            Color lightColor = door.isLocked() ? Color.RED : Color.GREEN;
            lightingEffect.addLightSource(
                new Point2D(door.getX() + door.getWidth()/2, door.getY() + door.getHeight()/2),
                60,
                lightColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add item lights
        for (Item item : roomItems) {
            Color itemColor = getItemColor(item.getType());
            lightingEffect.addLightSource(
                new Point2D(item.getX(), item.getY()),
                item.getSize() * 3,
                itemColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add enemy lights
        for (Enemy enemy : enemies) {
            Color enemyColor = Color.RED;
            if (enemy.getType() == Enemy.EnemyType.BOSS) {
                enemyColor = Color.DARKRED;
            } else if (enemy.getType() == Enemy.EnemyType.MAGE) {
                enemyColor = Color.BLUE;
            }
            
            lightingEffect.addLightSource(
                enemy.getPosition(),
                enemy.getSize() * 2,
                enemyColor,
                enemy.getType() == Enemy.EnemyType.BOSS ? 
                    LightingEffect.LightSource.LightType.PULSING : 
                    LightingEffect.LightSource.LightType.FLICKERING
            );
        }
        
        // Add environmental lights based on room type
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
            // Add lava lights for boss room
            for (int i = 0; i < 5; i++) {
                double x = random.nextDouble() * gameCanvas.getWidth();
                double y = random.nextDouble() * gameCanvas.getHeight();
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    30 + random.nextDouble() * 50,
                    Color.ORANGE,
                    LightingEffect.LightSource.LightType.FLICKERING
                );
            }
        } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            // Add arcane lights for puzzle room
            for (int i = 0; i < 4; i++) {
                double x = 100 + i * (gameCanvas.getWidth() - 200) / 3;
                double y = gameCanvas.getHeight() / 2;
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    70,
                    Color.CYAN,
                    LightingEffect.LightSource.LightType.PULSING
                );
            }
        }
    }
    
    private void renderUI(GraphicsContext gc) {
        if (player == null) return;
        
        // Set up fonts
        Font titleFont = Font.font("Arial", FontWeight.BOLD, 16);
        Font normalFont = Font.font("Arial", FontWeight.NORMAL, 14);
        
        // Draw player health bar
        double healthBarWidth = 200;
        double healthBarHeight = 20;
        double healthPercentage = (double) player.getHealth() / player.getMaxHealth();
        
        // Health bar background
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health bar fill
        Color healthColor;
        if (healthPercentage > 0.7) {
            healthColor = Color.GREEN;
        } else if (healthPercentage > 0.3) {
            healthColor = Color.YELLOW;
        } else {
            healthColor = Color.RED;
        }
        
        gc.setFill(healthColor);
        gc.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
        
        // Health bar border
        gc.setStroke(Color.BLACK);
        gc.setLineWidth(2);
        gc.strokeRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health text
        gc.setFill(Color.WHITE);
        gc.setFont(normalFont);
        gc.fillText("HP: " + (int)player.getHealth() + "/" + (int)player.getMaxHealth(), 
                    25, 36);
        
        // Draw current weapon info
        String weaponText = "Weapon: " + player.getCurrentWeapon().getType().getName();
        gc.fillText(weaponText, 20, 60);
        
        // Draw score
        gc.setFont(normalFont);
        gc.fillText("Score: " + player.getScore(), 20, 80);
        
        // Draw enemy count
        gc.fillText("Enemies: " + enemies.size(), 20, 100);
        
        // Draw level info
        gc.fillText("Level: " + currentLevel, 20, 120);
        
        // Draw current room type
        String roomTypeText = "Room: " + (currentRoom != null ? currentRoom.getType().toString() : "UNKNOWN");
        gc.fillText(roomTypeText, 20, 140);
        
        // Draw mini-map in top-right corner if needed
        if (isDebugMode) {
            drawMiniMap(gc);
        }
        
        // Draw FPS counter in debug mode
        if (isDebugMode) {
            long currentTime = System.nanoTime();
            double fps = 1_000_000_000.0 / (currentTime - lastUpdateTime);
            gc.fillText(String.format("FPS: %.1f", fps), gameCanvas.getWidth() - 100, 20);
        }
        
        // Controls reminder at the bottom
        gc.setFill(Color.LIGHTBLUE);
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                   gameCanvas.getWidth() / 2 - 200, gameCanvas.getHeight() - 20);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        double cellSize = 10;
        
        // Draw mini-map background
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw mini-map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Find min/max coordinates to center the map
        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
        
        for (DungeonRoom room : currentDungeon) {
            minX = Math.min(minX, room.getX());
            minY = Math.min(minY, room.getY());
            maxX = Math.max(maxX, room.getX());
            maxY = Math.max(maxY, room.getY());
        }
        
        // Calculate scaling to fit all rooms
        int mapWidth = maxX - minX + 1;
        int mapHeight = maxY - minY + 1;
        double scaleX = mapSize / (mapWidth * 1.5);
        double scaleY = mapSize / (mapHeight * 1.5);
        double scale = Math.min(scaleX, scaleY);
        
        // Calculate offset to center the map
        double offsetX = mapX + (mapSize - mapWidth * scale) / 2;
        double offsetY = mapY + (mapSize - mapHeight * scale) / 2;
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = offsetX + (room.getX() - minX) * scale;
            double roomY = offsetY + (room.getY() - minY) * scale;
            
            // Choose color based on room type
            Color roomColor;
            switch (room.getType()) {
                case SPAWN:
                    roomColor = Color.GREEN;
                    break;
                case BOSS:
                    roomColor = Color.RED;
                    break;
                case PUZZLE:
                    roomColor = Color.BLUE;
                    break;
                case TREASURE:
                    roomColor = Color.GOLD;
                    break;
                default:
                    roomColor = Color.GRAY;
            }
            
            // Draw room
            gc.setFill(room.isVisited() ? roomColor : Color.DARKGRAY);
            gc.fillRect(roomX, roomY, scale * 0.8, scale * 0.8);
            
            // If this is the current room, highlight it
            if (room == currentRoom) {
                gc.setStroke(Color.WHITE);
                gc.setLineWidth(2);
                gc.strokeRect(roomX, roomY, scale * 0.8, scale * 0.8);
            }
        }
        
        // Draw minimap legend
        double legendX = mapX + 10;
        double legendY = mapY + mapSize + 10;
        double legendBoxSize = 8;
        double textOffset = 15;
        
        gc.setFont(Font.font("Arial", FontWeight.NORMAL, 10));
        
        // Current room
        gc.setFill(Color.WHITE);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.fillText("Current", legendX + legendBoxSize + 5, legendY + 8);
        
        // Spawn room
        legendY += textOffset;
        gc.setFill(Color.GREEN);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Spawn", legendX + legendBoxSize + 5, legendY + 8);
        
        // Boss room
        legendY += textOffset;
        gc.setFill(Color.RED);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Boss", legendX + legendBoxSize + 5, legendY + 8);
        
        // Unvisited room
        legendY += textOffset;
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Unexplored", legendX + legendBoxSize + 5, legendY + 8);
    }

    public Player getPlayer() {
        return player;
    }

    private Color getItemColor(Item.ItemType type) {
        switch (type) {
            case WEAPON: return Color.RED;
            case POTION: return Color.GREEN;
            case ARMOR: return Color.BLUE;
            default: return Color.WHITE;
        }
    }

    private void createDoors() {
        // First remove existing doors
        doors.clear();
        
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors for null room");
            return;
        }
        
        System.out.println("Creating doors for room " + currentRoom.getType() + 
                          " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")");
        
        List<DungeonRoom> connectedRooms = currentRoom.getConnectedRooms();
        System.out.println("Connected rooms: " + connectedRooms.size());
        
        if (connectedRooms.isEmpty()) {
            System.err.println("WARNING: Room has no connected rooms!");
            return;
        }
        
        // Determine room bounds on the canvas
        double roomWidth = gameCanvas.getWidth() - 100;  // 50px margin on each side
        double roomHeight = gameCanvas.getHeight() - 100;
        double doorWidth = DOOR_WIDTH;
        double doorHeight = DOOR_HEIGHT;
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : connectedRooms) {
            if (connectedRoom == null) {
                System.err.println("WARNING: Connected room is null!");
                continue;
            }
            
            // Determine direction to the connected room
            int dx = connectedRoom.getX() - currentRoom.getX();
            int dy = connectedRoom.getY() - currentRoom.getY();
            
            System.out.println("Adding door to " + connectedRoom.getType() + 
                              " at direction (" + dx + "," + dy + ")");
            
            // Calculate door position based on direction
            double doorX, doorY;
            Door.DoorDirection doorDirection;
            
            if (dx > 0) {      // East door
                doorX = roomWidth - doorWidth + 50;
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.EAST;
            } else if (dx < 0) { // West door
                doorX = 50;  // Left margin
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.WEST;
            } else if (dy > 0) { // South door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = roomHeight - doorHeight + 50;
                doorDirection = Door.DoorDirection.SOUTH;
            } else {            // North door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = 50;  // Top margin
                doorDirection = Door.DoorDirection.NORTH;
            }
            
            // Create the door
            Door door = new Door(
                doorX, doorY, doorWidth, doorHeight,
                currentRoom, connectedRoom, doorDirection
            );
            
            // Lock doors based on room type
            if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT ||
                currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                // Combat rooms: doors are locked until enemies are defeated
                door.setLocked(!enemies.isEmpty());
                System.out.println("Combat/Boss room door locked state: " + door.isLocked() + 
                                 " (enemies: " + enemies.size() + ")");
            } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Puzzle rooms: doors are locked until puzzle is solved
                door.setLocked(!puzzleCompleted);
                door.setRequiresKey(true);
                System.out.println("Puzzle room door locked state: " + door.isLocked() + 
                                 " (puzzle completed: " + puzzleCompleted + ")");
            }
            
            doors.add(door);
            System.out.println("Added door at " + doorX + "," + doorY + 
                              " to " + connectedRoom.getType() + 
                              " (locked: " + door.isLocked() + ", requires key: " + door.requiresKey() + ")");
        }
        
        // Debug output of created doors
        if (doors.isEmpty()) {
            System.err.println("WARNING: No doors were created!");
        } else {
            System.out.println("Created " + doors.size() + " doors");
        }
    }
    
    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        roomCleared = false;
        
        System.out.println("Populating room of type: " + room.getType() + " at position " + room.getX() + "," + room.getY());
        
        // Get room center
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        Point2D roomCenter = new Point2D(centerX, centerY);
        
        switch (room.getType()) {
            case COMBAT:
                // Add enemies in combat rooms
                spawnEnemiesForRoom(room, false);
                
                // Add a health potion
                if (new Random().nextDouble() < 0.5) {
                    spawnBasicItem(roomCenter.add(50, 50));
                    System.out.println("Added health potion to combat room");
                }
                break;
                
            case BOSS:
                // Add boss enemy with enhanced spawning
                spawnEnemiesForRoom(room, true);
                break;
                
            case TREASURE:
                // Add random items
                System.out.println("Spawning items in treasure room");
                Random rnd = new Random();
                int itemCount = 2 + rnd.nextInt(3); // 2-4 items
                
                for (int i = 0; i < itemCount; i++) {
                    double angle = rnd.nextDouble() * Math.PI * 2; // Random angle
                    double distance = 50 + rnd.nextDouble() * 100; // Distance from center
                    
                    double offsetX = Math.cos(angle) * distance;
                    double offsetY = Math.sin(angle) * distance;
                    
                    spawnBasicItem(roomCenter.add(offsetX, offsetY));
                }
                break;
                
            case PUZZLE:
                // Add a key
                System.out.println("Adding key to puzzle room");
                placeKeyInRoom(room);
                break;
                
            case SPAWN:
            default:
                // No special spawns in spawn room
                break;
        }
        
        // Create doors for the new room
        createDoors();
    }
    
    /**
     * Enhanced enemy spawning system for rooms
     */
    private void spawnEnemiesForRoom(DungeonRoom room, boolean isBossRoom) {
        Random random = new Random();
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        if (isBossRoom) {
            System.out.println("Spawning boss in boss room");
            // Create a boss enemy
            Enemy bossEnemy = new Enemy(centerX, centerY, Enemy.EnemyType.BOSS);
            
            // Double the boss's max health and increase damage
            bossEnemy.setMaxHealth(bossEnemy.getMaxHealth() * 2);
            bossEnemy.heal(bossEnemy.getMaxHealth()); // Heal to full health
            
            // Add the boss
            enemies.add(bossEnemy);
            
            // Add minions around the boss
            int minionCount = 1 + random.nextInt(2); // 1-2 minions
            for (int i = 0; i < minionCount; i++) {
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 120 + random.nextInt(50);
                
                double enemyX = centerX + Math.cos(angle) * distance;
                double enemyY = centerY + Math.sin(angle) * distance;
                
                // Keep within bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Create a minion (using the constructor with behavior parameter)
                Enemy minion = new Enemy(enemyX, enemyY, Enemy.EnemyType.SKELETON, Enemy.BehaviorType.AGGRESSIVE, 1);
                enemies.add(minion);
            }
            
            System.out.println("Spawned boss with " + minionCount + " minions");
        } else {
            // Regular combat room
            int playerLevel = player != null ? player.getLevel() : 1;
            int roomDepth = Math.abs(room.getX()) + Math.abs(room.getY());
            
            // Adjust enemy count based on player level and room distance from spawn
            int baseEnemyCount = 2;
            int levelBonus = (playerLevel - 1) / 2; // Every 2 levels adds an enemy
            int depthBonus = roomDepth / 3; // Every 3 rooms deeper adds an enemy
            int maxEnemyCount = Math.min(6, baseEnemyCount + levelBonus + depthBonus);
            int enemyCount = baseEnemyCount + random.nextInt(maxEnemyCount - baseEnemyCount + 1);
            
            System.out.println("Spawning " + enemyCount + " enemies in combat room (player level: " + 
                              playerLevel + ", room depth: " + roomDepth + ")");
            
            // Determine possible enemy types based on depth
            List<Enemy.EnemyType> possibleTypes = new ArrayList<>();
            possibleTypes.add(Enemy.EnemyType.GOBLIN);  // Always available
            
            if (roomDepth > 1 || playerLevel > 1) {
                possibleTypes.add(Enemy.EnemyType.SKELETON);
            }
            
            if (roomDepth > 3 || playerLevel > 3) {
                possibleTypes.add(Enemy.EnemyType.ORC);
            }
            
            if (roomDepth > 5 || playerLevel > 5) {
                possibleTypes.add(Enemy.EnemyType.MAGE);
            }
            
            // Spawn enemies
            for (int i = 0; i < enemyCount; i++) {
                // Calculate random position within the room, away from center
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 100 + random.nextDouble() * 150;
                
                double offsetX = Math.cos(angle) * distance;
                double offsetY = Math.sin(angle) * distance;
                
                double enemyX = centerX + offsetX;
                double enemyY = centerY + offsetY;
                
                // Keep enemies within room bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Randomly select an enemy type from the available options
                Enemy.EnemyType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                
                // Determine behavior type
                Enemy.BehaviorType behaviorType;
                double behaviorRand = random.nextDouble();
                if (behaviorRand < 0.6) {
                    behaviorType = Enemy.BehaviorType.AGGRESSIVE;
                } else if (behaviorRand < 0.8) {
                    behaviorType = Enemy.BehaviorType.RANGED;
                } else if (behaviorRand < 0.9) {
                    behaviorType = Enemy.BehaviorType.PATROLLER;
                } else {
                    behaviorType = Enemy.BehaviorType.AMBUSHER;
                }
                
                // Create enemy with the determined behavior type
                Enemy enemy = new Enemy(enemyX, enemyY, type, behaviorType, 1);
                
                // Scale enemy based on room depth and player level
                if (roomDepth > 2 || playerLevel > 2) {
                    double healthMultiplier = 1.0 + (roomDepth * 0.1) + ((playerLevel - 1) * 0.05);
                    enemy.setMaxHealth(enemy.getMaxHealth() * healthMultiplier);
                    enemy.heal(enemy.getMaxHealth()); // Set to full health
                }
                
                enemies.add(enemy);
                System.out.println("Added enemy at " + enemyX + "," + enemyY + " of type: " + type + 
                                  ", behavior: " + enemy.getBehavior());
            }
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Determine number of items based on room type
        switch (room.getType()) {
            case COMBAT:
                itemCount = random.nextInt(2); // 0-1 items
                break;
            case PUZZLE:
                itemCount = 1; // Always spawn a key
                // Add a key to unlock doors
                placeKeyInRoom(room);
                break;
            case TREASURE:
                itemCount = random.nextInt(3) + 2; // 2-4 items
                break;
            case BOSS:
                itemCount = random.nextInt(2) + 1; // 1-2 special items
                break;
            case SPAWN:
                // No items in spawn room
                return;
        }
        
        // Add random items
        for (int i = 0; i < itemCount; i++) {
            addItemToRoom(room);
        }
    }
    
    private void placeKeyInRoom(DungeonRoom room) {
        // Get the center of the room on the canvas
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        // Add some randomness to key position
        Random random = new Random();
        double keyX = centerX + (random.nextDouble() - 0.5) * 100;
        double keyY = centerY + (random.nextDouble() - 0.5) * 100;
        
        // Create and add the key
        Item roomKey = new Item("Room Key", "Opens locked doors", Item.ItemType.KEY, 1, true);
        roomKey.setX(keyX);
        roomKey.setY(keyY);
        roomKey.setSize(20);
        
        System.out.println("Added key at position: " + keyX + "," + keyY);
        roomItems.add(roomKey);
    }
    
    private void spawnBasicItem(Point2D position) {
        Random random = new Random();
        
        // Randomize item type
        Item.ItemType type;
        String name;
        String description;
        int value;
        boolean consumable;
        
        double rnd = random.nextDouble();
        if (rnd < 0.6) {
            // 60% chance for a potion
            type = Item.ItemType.POTION;
            name = "Health Potion";
            description = "Restores 20 health";
            value = 20;
            consumable = true;
        } else if (rnd < 0.8) {
            // 20% chance for a weapon
            type = Item.ItemType.WEAPON;
            name = "Sword";
            description = "A sharp weapon";
            value = 15;
            consumable = false;
        } else {
            // 20% chance for treasure
            type = Item.ItemType.TREASURE;
            name = "Gold Coins";
            description = "Valuable treasure";
            value = 50;
            consumable = true;
        }
        
        // Create the item
        Item item = new Item(name, description, type, value, consumable);
        item.setX(position.getX());
        item.setY(position.getY());
        item.setSize(20);
        
        System.out.println("Added item: " + name + " at " + position.getX() + "," + position.getY());
        
        roomItems.add(item);
    }
    
    private void spawnEnemy(DungeonRoom room) {
        Random random = new Random();
        Point2D roomPos = new Point2D(room.getX(), room.getY());
        Point2D randomOffset = new Point2D(
            random.nextDouble() * room.getWidth(),
            random.nextDouble() * room.getHeight()
        );
        Point2D spawnPos = roomPos.add(randomOffset).multiply(8); // Scale to pixel coordinates
        
        Enemy.EnemyType type = random.nextBoolean() ? Enemy.EnemyType.GOBLIN : Enemy.EnemyType.SKELETON;
        enemies.add(new Enemy(spawnPos.getX(), spawnPos.getY(), type));
    }

    private boolean isColliding(Entity entity1, Entity entity2) {
        Point2D center1 = entity1.getPosition().add(entity1.getSize() / 2, entity1.getSize() / 2);
        Point2D center2 = entity2.getPosition().add(entity2.getSize() / 2, entity2.getSize() / 2);
        double distance = center1.distance(center2);
        double combinedRadius = (entity1.getSize() + entity2.getSize()) / 2;
        return distance < combinedRadius;
    }

    private boolean isInMeleeRange(Entity attacker, Entity target) {
        double attackRange = 40; // Melee attack range
        
        Point2D attackerCenter = attacker.getPosition().add(new Point2D(attacker.getSize() / 2, attacker.getSize() / 2));
        Point2D targetCenter = target.getPosition().add(new Point2D(target.getSize() / 2, target.getSize() / 2));
        
        return attackerCenter.distance(targetCenter) < (attacker.getSize() / 2 + target.getSize() / 2 + attackRange);
    }

    private void showFloatingText(String text, Point2D position) {
        // This would be implemented with a UI element that floats up and fades out
        // For now, we'll just print to console
        System.out.println("Floating text at " + position + ": " + text);
    }

    private void dropRandomItem(Point2D position) {
        Random random = new Random();
        if (random.nextDouble() < 0.3) { // 30% chance to drop an item
            Item.ItemType type = Item.ItemType.values()[random.nextInt(Item.ItemType.values().length)];
            String name;
            String description;
            int value;
            boolean consumable;
            
            switch (type) {
                case WEAPON:
                    name = "Sword";
                    description = "A sharp blade";
                    value = 10;
                    consumable = false;
                    break;
                case POTION:
                    name = "Health Potion";
                    description = "Restores 20 HP";
                    value = 20;
                    consumable = true;
                    break;
                case ARMOR:
                    name = "Shield";
                    description = "Provides protection";
                    value = 15;
                    consumable = false;
                    break;
                default:
                    name = "Gold Coins";
                    description = "Valuable treasure";
                    value = 50;
                    consumable = true;
                    type = Item.ItemType.TREASURE;
                    break;
            }
            
            // Create and add the item
            Item item = new Item(name, description, type, value, consumable);
            item.setX(position.getX());
            item.setY(position.getY());
            item.setSize(20);
            roomItems.add(item);
        }
    }

    private boolean isPlayerTouchingItem(Item item) {
        double playerCenterX = player.getPosition().getX() + player.getSize() / 2;
        double playerCenterY = player.getPosition().getY() + player.getSize() / 2;
        double itemCenterX = item.getX() + 5; // Assuming item size is 10x10
        double itemCenterY = item.getY() + 5;
        
        double distance = Math.sqrt(
            Math.pow(playerCenterX - itemCenterX, 2) + 
            Math.pow(playerCenterY - itemCenterY, 2)
        );
        
        return distance < (player.getSize() / 2 + 5); // Player radius + item radius
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                System.out.println("Player touching door to " + door.getConnectedRoom().getType() + 
                                  " - Door locked: " + door.isLocked() + 
                                  ", Requires key: " + door.requiresKey());
                
                if (!door.isLocked()) {
                    // Get the connected room
                    DungeonRoom targetRoom = door.getConnectedRoom();
                    if (targetRoom != null) {
                        System.out.println("Door unlocked - transitioning to room: " + targetRoom.getType() + 
                                          " at position " + targetRoom.getX() + "," + targetRoom.getY());
                        
                        // Calculate entry position based on door direction
                        Point2D entryPosition = getEntryPosition(door);
                        
                        // Pass target room and entry position to transition method
                        transitionToRoom(targetRoom, entryPosition);
                        
                        // Update difficulty based on room type if it's a boss room
                        if (targetRoom.getType() == DungeonRoom.RoomType.BOSS) {
                            adjustDifficultyForLevel();
                        }
                        
                        break;
                    } else {
                        System.err.println("ERROR: Connected room is null!");
                    }
                } else {
                    // Show message about locked door if player is touching it
                    if (door.requiresKey()) {
                        effectsManager.showFloatingText("This door requires a key", 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.YELLOW);
                        
                        // Try to unlock with key if player has one
                        if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                            if (door.unlock(player.getInventory())) {
                                effectsManager.showFloatingText("Door unlocked!", 
                                    new Point2D(door.getX() + door.getWidth()/2, door.getY() - 10),
                                    Color.GREEN);
                                // Door is now unlocked, but wait for next check to transition
                            }
                        }
                    } else {
                        // Door is locked for other reasons (enemies not defeated)
                        String message = "Defeat all enemies to unlock";
                        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                            message = "Solve the puzzle to unlock";
                        }
                        effectsManager.showFloatingText(message, 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.RED);
                    }
                }
            }
        }
    }

    private void transitionToRoom(DungeonRoom room) {
        if (roomTransitionInProgress || room == null) {
            System.out.println("Cannot transition to room: " + (room == null ? "null" : room.getType()) + 
                               ", transition in progress: " + roomTransitionInProgress);
            return;
        }
        
        System.out.println("Starting transition to " + room.getType() + " room at position " + room.getX() + "," + room.getY());
        roomTransitionInProgress = true;
        
        // Create a fade transition effect
        Rectangle fadeRect = new Rectangle(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        fadeRect.setFill(Color.BLACK);
        fadeRect.setOpacity(0);
        rootPane.getChildren().add(fadeRect);
        
        // Create fade out transition
        javafx.animation.FadeTransition fadeOut = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeOut.setFromValue(0);
        fadeOut.setToValue(1);
        
        // Create fade in transition
        javafx.animation.FadeTransition fadeIn = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeIn.setFromValue(1);
        fadeIn.setToValue(0);
        
        // Add visual effects for room transition
        effectsManager.addRoomTransitionEffect();
        
        // Set up the sequence
        fadeOut.setOnFinished(e -> {
            // Change room
            currentRoom = room;
            currentRoom.setVisited(true);
            
            // Reset player position to center of new room
            double roomCenterX = currentRoom.getX() + currentRoom.getWidth() / 2 - player.getSize() / 2;
            double roomCenterY = currentRoom.getY() + currentRoom.getHeight() / 2 - player.getSize() / 2;
            player.setPosition(new Point2D(roomCenterX, roomCenterY));
            
            // Clear enemies and items from previous room
            enemies.clear();
            projectiles.clear();
            roomItems.clear();
            doors.clear();
            
            // Populate new room
            populateRoom(currentRoom);
            
            // Create doors for the new room
            createDoors();
            
            // Update minimap
            updateMinimap();
        });
        
        fadeIn.setOnFinished(e -> {
            // Remove the fade rectangle
            rootPane.getChildren().remove(fadeRect);
            roomTransitionInProgress = false;
            
            // Display room entrance message
            String roomTypeText = "";
            switch (currentRoom.getType()) {
                case COMBAT:
                    roomTypeText = "Combat Room";
                    break;
                case PUZZLE:
                    roomTypeText = "Puzzle Room";
                    break;
                case TREASURE:
                    roomTypeText = "Treasure Room";
                    break;
                case BOSS:
                    roomTypeText = "Boss Room";
                    break;
                case SPAWN:
                    roomTypeText = "Starting Room";
                    break;
            }
            
            // Show floating text for room type
            showFloatingText("Entered: " + roomTypeText, 
                new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4));
                
            // Initialize room-specific lighting
            updateLighting();
        });
        
        // Start the transition
        fadeOut.play();
    }
    
    private void handleDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
        }
        
        // Draw player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw enemies
        for (Enemy enemy : enemies) {
            enemy.render(gc);
        }
        
        // Draw player projectiles
        for (Projectile projectile : playerProjectiles) {
            projectile.render(gc);
        }
        
        // Draw enemy projectiles
        for (EnemyAbility.Projectile projectile : enemyProjectiles) {
            projectile.render(gc);
        }
        
        // Draw floating texts
        for (String text : floatingTexts) {
            effectsManager.renderFloatingText(gc, text);
        }
        
        // Draw minimap
        drawMiniMap(gc);
        
        // Draw pause button
        drawPauseButton(gc);
        
        // Draw controls guide
        drawControlsGuide(gc);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        
        // Draw map background
        gc.setFill(Color.BLACK);
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Calculate map scale
        double mapScale = mapSize / currentDungeon.size();
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = mapX + room.getX() * mapScale;
            double roomY = mapY + room.getY() * mapScale;
            double roomSize = mapScale - 2;
            
            // Draw room background
            gc.setFill(getRoomColor(room.getType()));
            gc.fillRect(roomX, roomY, roomSize, roomSize);
            
            // Draw room border
            gc.setStroke(Color.WHITE);
            gc.setLineWidth(1);
            gc.strokeRect(roomX, roomY, roomSize, roomSize);
        }
        
        // Draw player position
        if (player != null && currentRoom != null) {
            double playerX = mapX + currentRoom.getX() * mapScale + mapScale / 2;
            double playerY = mapY + currentRoom.getY() * mapScale + mapScale / 2;
            
            gc.setFill(Color.RED);
            gc.fillOval(playerX - 3, playerY - 3, 6, 6);
        }
    }

    private Color getRoomColor(DungeonRoom.RoomType roomType) {
        switch (roomType) {
            case SPAWN:
                return Color.GREEN;
            case COMBAT:
                return Color.RED;
            case PUZZLE:
                return Color.BLUE;
            case TREASURE:
                return Color.YELLOW;
            case BOSS:
                return Color.PURPLE;
            default:
                return Color.WHITE;
        }
    }

    private void drawPauseButton(GraphicsContext gc) {
        double buttonSize = 30;
        double x = gameCanvas.getWidth() - buttonSize - 20;
        double y = gameCanvas.getHeight() - buttonSize - 20;
        
        // Draw button background
        gc.setFill(Color.BLACK);
        gc.fillRect(x, y, buttonSize, buttonSize);
        
        // Draw pause icon
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(2);
        if (isPaused) {
            // Draw play icon
            gc.strokePolygon(new double[]{x + 10, x + 20, x + 10}, 
                            new double[]{y + 10, y + 20, y + 10}, 
                            3);
        } else {
            // Draw pause icon
            gc.strokeRect(x + 10, y + 10, 5, 10);
            gc.strokeRect(x + 20, y + 10, 5, 10);
        }
    }

    private void drawControlsGuide(GraphicsContext gc) {
        double x = 20;
        double y = gameCanvas.getHeight() - 20;
        
        gc.setFill(Color.WHITE);
        gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
        
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                    x, y);
    }

    private Color getItemColor(Item.ItemType itemType) {
        switch (itemType) {
            case POTION:
                return Color.RED;
            case WEAPON:
                return Color.ORANGE;
            case ARMOR:
                return Color.BLUE;
            case KEY:
                return Color.YELLOW;
            default:
                return Color.WHITE;
        }
    }

    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            return;
        }
        
        // Set background color based on room type
        Color backgroundColor = getRoomBackgroundColor(currentRoom.getType());
        gc.setFill(backgroundColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
    }

    private Color getRoomBackgroundColor(DungeonRoom.RoomType roomType) {
        switch (roomType) {
            case SPAWN:
                return Color.GREEN;
            case COMBAT:
                return Color.RED;
            case PUZZLE:
                return Color.BLUE;
            case TREASURE:
                return Color.YELLOW;
            case BOSS:
                return Color.PURPLE;
            default:
                return Color.WHITE;
        }
    }

    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Update lighting effect based on player position
        lightingEffect.update(player.getX(), player.getY());
    }

    private void update(double deltaTime) {
        // Debug game state
        System.out.println("UPDATE CALLED | gameLoopRunning=" + gameLoopRunning + 
                          " | roomTransitionInProgress=" + roomTransitionInProgress);
                          
        // Check if player is initialized
        if (player == null) {
            System.out.println("ERROR: Player is null in update method");
            setupGame(); // Try to re-initialize the game
            return;
        }
        
        // Check if current room is initialized
        if (currentRoom == null) {
            System.out.println("ERROR: Current room is null in update method");
            setupGame(); // Try to re-initialize the game
            return;
        }
        
        // Skip update if room transition is in progress
        if (roomTransitionInProgress) {
            return;
        }
        
        // Debug message for room type
        String roomType = currentRoom.getType().toString();
        System.out.println("Current room type: " + roomType + " | Enemies: " + enemies.size() + " | Items: " + roomItems.size() + " | Projectiles: " + playerProjectiles.size());
        
        // Handle player input
        player.handleInput(activeKeys, deltaTime);
        
        // Move player
        movePlayer(deltaTime);
        
        // Check for item pickups
        checkItemPickups();
        
        // Check for door interactions
        checkDoorInteraction();
        
        // Check for room transitions
        checkRoomTransition();
        
        // Update enemies
        updateEnemies(deltaTime);
        
        // Update projectiles
        updateProjectiles(deltaTime);
        
        // Update player projectiles
        updatePlayerProjectiles(deltaTime);
        
        // Check for enemy defeat conditions
        checkRoomClearConditions();
        
        // Check player status
        checkPlayerStatus();
        
        // Check victory condition
        checkVictoryCondition();
        
        // Update effects
        effectsManager.update(deltaTime);
        
        // Update lighting
        updateLighting();
    }

    private void movePlayer(double deltaTime) {
        if (player == null) {
            System.err.println("ERROR: Cannot move player - player is null");
            return;
        }
        
        // Calculate player movement
        double moveX = 0;
        double moveY = 0;
        
        if (activeKeys.contains(KeyCode.W)) {
            moveY -= player.getSpeed() * deltaTime;
        }
        if (activeKeys.contains(KeyCode.S)) {
            moveY += player.getSpeed() * deltaTime;
        }
        if (activeKeys.contains(KeyCode.A)) {
            moveX -= player.getSpeed() * deltaTime;
        }
        if (activeKeys.contains(KeyCode.D)) {
            moveX += player.getSpeed() * deltaTime;
        }
        
        // Update player position
        player.move(moveX, moveY);
        
        // Keep player within canvas bounds
        double playerX = player.getX();
        double playerY = player.getY();
        
        if (playerX < 0) {
            player.setPosition(0, playerY);
        } else if (playerX > gameCanvas.getWidth() - player.getWidth()) {
            player.setPosition(gameCanvas.getWidth() - player.getWidth(), playerY);
        }
        
        if (playerY < 0) {
            player.setPosition(playerX, 0);
        } else if (playerY > gameCanvas.getHeight() - player.getHeight()) {
            player.setPosition(playerX, gameCanvas.getHeight() - player.getHeight());
        }
    }

    private void checkItemPickups() {
        Iterator<Item> itemIterator = roomItems.iterator();
        while (itemIterator.hasNext()) {
            Item item = itemIterator.next();
            
            // Debug print
            System.out.println("Checking item: " + item.getName() + " at " + item.getX() + "," + item.getY());
            System.out.println("Player position: " + player.getX() + "," + player.getY());

            // Improved collision detection for items
            Point2D playerCenter = player.getPosition().add(player.getSize() / 2, player.getSize() / 2);
            Point2D itemCenter = new Point2D(item.getX(), item.getY());
            double distance = playerCenter.distance(itemCenter);

            // If player is close enough to item
            if (distance < (player.getSize() / 2 + item.getSize() / 2)) {
                System.out.println("Player picked up: " + item.getName());
                
                // Handle item pickup based on type
                switch (item.getType()) {
                    case POTION:
                        player.heal(20); // Heal player by 20 HP
                        effectsManager.showFloatingText("+" + 20 + " HP", 
                            player.getPosition(), Color.GREEN);
                        player.addScore(25); // Add score for potion
                        break;
                    case WEAPON:
                        // Add weapon to inventory
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.YELLOW);
                        player.addScore(50); // Add score for weapon
                        break;
                    case ARMOR:
                        // Add armor to inventory
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.BLUE);
                        player.addScore(50); // Add score for armor
                        break;
                    case KEY:
                        // Unlock all doors in the current room
                        unlockDoorsWithKey();
                        effectsManager.showFloatingText("Doors unlocked!", 
                            player.getPosition(), Color.GOLD);
                        player.addScore(100); // Add score for key
                        break;
                    default:
                        // Generic pickup
                        player.addItem(item);
                        effectsManager.showFloatingText("Picked up " + item.getName(), 
                            player.getPosition(), Color.WHITE);
                        player.addScore(25); // Default score addition
                        break;
                }
                
                // Remove item from room
                itemIterator.remove();
            }
        }
    }

    private void unlockDoorsWithKey() {
        for (Door door : doors) {
            if (door.requiresKey()) {
                door.unlockWithKey();
            }
        }
    }

    private void checkDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }

    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }

    private void checkPlayerStatus() {
        // Check if player is dead
        if (player.isDead()) {
            // Handle game over
            handleGameOver();
        }
    }

    private void checkVictoryCondition() {
        // Check if player has reached the end of the game
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && bossDefeated) {
            // Handle victory
            handleVictory();
        }
    }

    private void handleGameOver() {
        // Show game over screen
        showGameOverScreen();
        
        // Stop game loop
        gameLoopRunning = false;
    }

    private void handleVictory() {
        // Show victory screen
        showVictoryScreen();
        
        // Stop game loop
        gameLoopRunning = false;
    }

    private void showGameOverScreen() {
        try {
            // Load the game over screen
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/GameOver.fxml"));
            Parent gameOverRoot = loader.load();
            Scene gameOverScene = new Scene(gameOverRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(gameOverScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void showVictoryScreen() {
        try {
            // Load the victory screen
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/Victory.fxml"));
            Parent victoryRoot = loader.load();
            Scene victoryScene = new Scene(victoryRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(victoryScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void updateEnemies(double deltaTime) {
        Iterator<Enemy> enemyIterator = enemies.iterator();
        while (enemyIterator.hasNext()) {
            Enemy enemy = enemyIterator.next();
            
            // Update enemy position and behavior
            enemy.update(deltaTime, player);
            
            // Check if enemy is dead
            if (enemy.isDead()) {
                // Remove enemy from the list
                enemyIterator.remove();
                
                // Add score for defeating enemy
                player.addScore(100);
            }
        }
    }

    private void updateProjectiles(double deltaTime) {
        // Update player projectiles
        updatePlayerProjectiles(deltaTime);
        
        // Update enemy projectiles
        updateEnemyProjectiles(deltaTime);
    }

    private void updatePlayerProjectiles(double deltaTime) {
        Iterator<Projectile> projectileIterator = playerProjectiles.iterator();
        while (projectileIterator.hasNext()) {
            Projectile projectile = projectileIterator.next();
            
            // Update projectile position
            projectile.update(deltaTime);
            
            // Check if projectile is out of bounds
            if (isOutOfBounds(projectile)) {
                projectileIterator.remove();
                continue;
            }
            
            // Check for collisions with enemies
            for (Enemy enemy : enemies) {
                if (projectile.checkCollision(enemy)) {
                    // Apply damage to enemy
                    enemy.takeDamage(projectile.getDamage());
                    
                    // Show damage text
                    effectsManager.showFloatingText("-" + (int)projectile.getDamage(), 
                        enemy.getPosition(), Color.ORANGE);
                    
                    // Remove projectile
                    projectileIterator.remove();
                    break;
                }
            }
        }
    }

    private void updateEnemyProjectiles(double deltaTime) {
        Iterator<EnemyAbility.Projectile> projectileIterator = enemyProjectiles.iterator();
        while (projectileIterator.hasNext()) {
            EnemyAbility.Projectile projectile = projectileIterator.next();
            
            // Update projectile position
            projectile.update(deltaTime);
            
            // Check if projectile is out of bounds
            if (isOutOfBounds(projectile)) {
                projectileIterator.remove();
                continue;
            }
            
            // Check for collision with player
            if (projectile.checkCollision(player)) {
                // Apply damage to player
                player.takeDamage(projectile.getDamage());
                
                // Show damage text
                effectsManager.showFloatingText("-" + (int)projectile.getDamage(), 
                    player.getPosition(), Color.RED);
                
                // Remove projectile
                projectileIterator.remove();
            }
        }
    }

    private boolean isOutOfBounds(Projectile projectile) {
        return projectile.getX() < 0 || projectile.getX() > gameCanvas.getWidth() || 
               projectile.getY() < 0 || projectile.getY() > gameCanvas.getHeight();
    }

    private void firePlayerProjectile() {
        // Create a new player projectile
        Projectile projectile = player.fireProjectile();
        if (projectile != null) {
            playerProjectiles.add(projectile);
        }
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                // Handle door interaction
                handleDoorInteraction(door);
            }
        }
    }

    private boolean isPlayerTouchingDoor(Door door) {
        if (player == null) return false;
        return door.contains(player.getPosition());
    }

    private void handleDoorInteraction(Door door) {
        if (door.isLocked()) {
            // Check if player has a key
            if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                // Unlock the door
                door.unlockWithKey();
                effectsManager.showFloatingText("Door unlocked!", 
                    player.getPosition(), Color.GOLD);
            } else {
                // Show locked door message
                effectsManager.showFloatingText("Door is locked", 
                    player.getPosition(), Color.RED);
            }
        } else {
            // Transition to the connected room
            transitionToRoom(door.getConnectedRoom());
        }
    }

    private void transitionToRoom(DungeonRoom targetRoom) {
        if (targetRoom == null) {
            System.err.println("ERROR: Cannot transition to null room");
            return;
        }
        
        // Set the current room to the target room
        currentRoom = targetRoom;
        currentRoom.setVisited(true);
        
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        doors.clear();
        
        // Populate the new room
        populateRoom(currentRoom);
        createDoors();
        
        // Reset player position
        player.setPosition(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 2);
        
        // Update minimap
        updateMinimap();
    }

    private void updateMinimap() {
        // Update minimap cells
        for (DungeonRoom room : currentDungeon) {
            Rectangle cell = minimapCells.get(room);
            if (cell != null) {
                cell.setFill(room.isVisited() ? Color.LIGHTGRAY : Color.DARKGRAY);
            }
        }
    }

    private void enhancedDoorInteraction() {
        // Check if player is touching a door
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                // Handle door interaction
                handleDoorInteraction(door);
                break; // Only interact with one door at a time
            }
        }
    }

    private void selectWeapon(int weaponIndex) {
        // Check if weapon index is valid
        if (weaponIndex >= 0 && weaponIndex < player.getInventory().getWeapons().size()) {
            // Get the selected weapon
            Item weapon = player.getInventory().getWeapons().get(weaponIndex);
            
            // Equip the weapon
            player.equipWeapon(weapon);
            
            // Show weapon selection message
            effectsManager.showFloatingText("Equipped " + weapon.getName(), 
                player.getPosition(), Color.YELLOW);
        } else {
            // Show invalid weapon selection message
            effectsManager.showFloatingText("Invalid weapon selection", 
                player.getPosition(), Color.RED);
        }
    }

    private void openInventory() {
        // Show inventory screen
        try {
            // Load the inventory screen
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/Inventory.fxml"));
            Parent inventoryRoot = loader.load();
            Scene inventoryScene = new Scene(inventoryRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(inventoryScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void interactWithPuzzle() {
        // Show puzzle screen
        try {
            // Load the puzzle screen
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/Puzzle.fxml"));
            Parent puzzleRoot = loader.load();
            Scene puzzleScene = new Scene(puzzleRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(puzzleScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void togglePauseGame() {
        isPaused = !isPaused;
        
        if (isPaused) {
            pauseMenu.setVisible(true);
            // Stop the game loop
            gameLoopRunning = false;
            
            System.out.println("Game paused");
        } else {
            pauseMenu.setVisible(false);
            // Resume the game loop
            gameLoopRunning = true;
            startGameLoop();
            
            // Make sure canvas has focus
            gameCanvas.requestFocus();
            
            System.out.println("Game resumed");
        }
    }

    private void resumeGame() {
        isPaused = false;
        pauseMenu.setVisible(false);
        gameLoopRunning = true;
        startGameLoop();
        
        // Make sure canvas has focus
        gameCanvas.requestFocus();
    }

    private void showOptions() {
        // In a full implementation, you would show options dialog
        // For now, just show a message
        System.out.println("Options would be shown here");
    }

    private void exitToMainMenu() {
        try {
            // Load the main menu
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/com/dungeon/fxml/MainMenu.fxml"));
            Parent menuRoot = loader.load();
            Scene menuScene = new Scene(menuRoot);
            
            // Get the current stage and set the new scene
            Stage stage = (Stage) gameCanvas.getScene().getWindow();
            stage.setScene(menuScene);
            stage.show();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void createMenuBar() {
        // Create menu bar
        menuBar = new javafx.scene.control.MenuBar();
        
        // Create menus
        javafx.scene.control.Menu gameMenu = new javafx.scene.control.Menu("Game");
        javafx.scene.control.Menu optionsMenu = new javafx.scene.control.Menu("Options");
        
        // Create menu items
        javafx.scene.control.MenuItem pauseItem = new javafx.scene.control.MenuItem("Pause");
        pauseItem.setOnAction(e -> togglePauseGame());
        
        javafx.scene.control.MenuItem exitItem = new javafx.scene.control.MenuItem("Exit to Main Menu");
        exitItem.setOnAction(e -> exitToMainMenu());
        
        // Add menu items to menus
        gameMenu.getItems().addAll(pauseItem, exitItem);
        
        // Add menus to menu bar
        menuBar.getMenus().addAll(gameMenu, optionsMenu);
        
        // Add menu bar to root pane
        rootPane.setTop(menuBar);
    }

    private void handleResize() {
        if (canvasContainer == null || gameCanvas == null) {
            System.err.println("WARNING: canvasContainer or gameCanvas is null in handleResize");
            return;
        }
        
        System.out.println("Setting up window resize handling...");
        
        // Bind canvas size to parent container size
        gameCanvas.widthProperty().bind(canvasContainer.widthProperty());
        gameCanvas.heightProperty().bind(canvasContainer.heightProperty());
        
        // Add listener for canvas width changes
        gameCanvas.widthProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            
            System.out.println("Canvas width changed: " + oldVal + " -> " + newVal);
            
            // Force rendering if player exists and game is not paused
            if (player != null && !isPaused) {
                // Keep player in the bounds of the new canvas
                double playerX = player.getX();
                if (playerX > newVal.doubleValue() - player.getWidth()) {
                    player.setPosition(newVal.doubleValue() - player.getWidth(), player.getY());
                }
                
                // Render the updated scene
                render();
            }
        });
        
        // Add listener for canvas height changes
        gameCanvas.heightProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            
            System.out.println("Canvas height changed: " + oldVal + " -> " + newVal);
            
            // Force rendering if player exists and game is not paused
            if (player != null && !isPaused) {
                // Keep player in the bounds of the new canvas
                double playerY = player.getY();
                if (playerY > newVal.doubleValue() - player.getHeight()) {
                    player.setPosition(player.getX(), newVal.doubleValue() - player.getHeight());
                }
                
                // Render the updated scene
                render();
            }
        });
        
        // Also bind the root pane to the scene size
        if (rootPane != null && rootPane.getScene() != null) {
            rootPane.prefWidthProperty().bind(rootPane.getScene().widthProperty());
            rootPane.prefHeightProperty().bind(rootPane.getScene().heightProperty());
        }
        
        System.out.println("Window resize handling set up successfully");
    }

    private void createPauseMenu() {
        pauseMenu = new javafx.scene.layout.VBox(10);
        pauseMenu.setAlignment(javafx.geometry.Pos.CENTER);
        pauseMenu.setStyle("-fx-background-color: rgba(0, 0, 0, 0.7); -fx-padding: 20px;");
        pauseMenu.setPrefWidth(300);
        pauseMenu.setPrefHeight(200);
        
        // Create title
        javafx.scene.text.Text title = new javafx.scene.text.Text("Paused");
        title.setFont(javafx.scene.text.Font.font("Verdana", javafx.scene.text.FontWeight.BOLD, 24));
        title.setFill(javafx.scene.paint.Color.WHITE);
        
        // Create buttons
        javafx.scene.control.Button resumeButton = new javafx.scene.control.Button("Resume Game");
        resumeButton.setPrefWidth(200);
        resumeButton.setOnAction(e -> resumeGame());
        
        javafx.scene.control.Button optionsButton = new javafx.scene.control.Button("Options");
        optionsButton.setPrefWidth(200);
        optionsButton.setOnAction(e -> showOptions());
        
        javafx.scene.control.Button exitButton = new javafx.scene.control.Button("Exit to Main Menu");
        exitButton.setPrefWidth(200);
        exitButton.setOnAction(e -> exitToMainMenu());
        
        // Add components to menu
        pauseMenu.getChildren().addAll(title, resumeButton, optionsButton, exitButton);
        
        // Center the pause menu
        javafx.scene.layout.StackPane.setAlignment(pauseMenu, javafx.geometry.Pos.CENTER);
        
        // Initially hide the pause menu
        pauseMenu.setVisible(false);
        
        // Add to root pane
        rootPane.getChildren().add(pauseMenu);
    }

    private void startGameLoop() {
        // Don't create a new AnimationTimer if we already have one running
        if (gameLoopRunning) {
            lastUpdateTime = System.nanoTime();
            
            AnimationTimer timer = new AnimationTimer() {
                @Override
                public void handle(long now) {
                    if (gameLoopRunning && !roomTransitionInProgress && !isPaused) {
                        double deltaTime = (now - lastUpdateTime) / 1_000_000_000.0;
                        lastUpdateTime = now;
                        
                        update(deltaTime);
                        render();
                    }
                }
            };
            
            timer.start();
        }
    }

    private void setupGame() {
        // Initialize game components
        random = new Random();
        activeKeys = new HashSet<>();
        enemies = new ArrayList<>();
        roomItems = new ArrayList<>();
        doors = new ArrayList<>();
        playerProjectiles = new ArrayList<>();
        projectiles = new ArrayList<>();
        
        // Initialize effects manager if not already initialized
        if (effectsManager == null) {
            effectsManager = new EffectsManager(rootPane, gameCanvas);
        }
        
        // Set gameLoopRunning flag
        gameLoopRunning = true;
        
        // Generate dungeon
        System.out.println("Generating dungeon...");
        dungeonGenerator = new DungeonGenerator();
        currentDungeon = dungeonGenerator.generateDungeon();
        
        System.out.println("Dungeon created with " + currentDungeon.size() + " rooms");
        
        // Set current room to spawn room
        java.util.Optional<DungeonRoom> spawnRoom = currentDungeon.stream()
            .filter(room -> room.getType() == DungeonRoom.RoomType.SPAWN)
            .findFirst();
            
        if (spawnRoom.isPresent()) {
            currentRoom = spawnRoom.get();
            currentRoom.setVisited(true);
            
            System.out.println("Found spawn room: " + currentRoom);
            
            // Generate puzzles for puzzle rooms
            generatePuzzles();
            
            // Find spawn room and place player
            Point2D spawnPoint = new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 2);
            player = new Player(spawnPoint.getX(), spawnPoint.getY());
            
            System.out.println("Player created at " + spawnPoint);
            
            populateRoom(currentRoom);
            createDoors();
        } else {
            System.err.println("ERROR: No spawn room found in dungeon!");
        }
    }

    private void generatePuzzles() {
        for (DungeonRoom room : currentDungeon) {
            if (room.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Create a random puzzle for each puzzle room
                puzzles.put(room, Puzzle.createRandomPuzzle());
            }
        }
    }

    private void setupInputHandling() {
        if (gameCanvas == null) {
            System.err.println("ERROR: gameCanvas is null in setupInputHandling");
            return;
        }
        
        // Handle keyboard input
        gameCanvas.setOnKeyPressed(e -> {
            // Add key to active keys
            activeKeys.add(e.getCode());
            
            // Special key handlers
            switch (e.getCode()) {
                case ESCAPE:
                    // Toggle pause menu
                    togglePauseGame();
                    break;
                    
                case I:
                    // Open inventory
                    if (!isPaused) {
                        openInventory();
                    }
                    break;
                    
                case F:
                    // Use health potion
                    if (player.getInventory().hasItem(Item.ItemType.POTION)) {
                        Item potion = player.getInventory().getItems().stream()
                            .filter(item -> item.getType() == Item.ItemType.POTION)
                            .findFirst().orElse(null);
                        
                        if (potion != null) {
                            player.useItem(potion);
                            effectsManager.showFloatingText("Used healing potion!", 
                                player.getPosition().add(0, -20), Color.GREEN);
                        }
                    } else {
                        effectsManager.showFloatingText("No healing potions!", 
                            player.getPosition().add(0, -20), Color.RED);
                    }
                    break;
                    
                case E:
                    // Interact with objects
                    handleDoorInteraction();
                    
                    // Interact with puzzle or door
                    if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE && !puzzles.get(currentRoom).isSolved()) {
                        interactWithPuzzle();
                    }
                    break;
                    
                case DIGIT1:
                    // Select weapon 1 (Sword)
                    selectWeapon(0);
                    break;
                    
                case DIGIT2:
                    // Select weapon 2 (Bow)
                    selectWeapon(1);
                    break;
                    
                case DIGIT3:
                    // Select weapon 3 (Staff)
                    selectWeapon(2);
                    break;
                    
                case DIGIT4:
                    // Select weapon 4 (Axe)
                    selectWeapon(3);
                    break;
                    
                case SPACE:
                    // Melee attack
                    attackEnemiesInRange();
                    break;
                    
                case M:
                    // Toggle debug mode
                    isDebugMode = !isDebugMode;
                    System.out.println("Debug mode: " + isDebugMode);
                    break;
                    
                default:
                    // Other keys handled by active keys set
                    break;
            }
        });
        
        gameCanvas.setOnKeyReleased(e -> {
            // Remove key from active keys
            activeKeys.remove(e.getCode());
        });
        
        // Handle mouse input
        gameCanvas.setOnMouseMoved(e -> {
            mouseX = e.getX();
            mouseY = e.getY();
            
            // Update player aim direction
            if (player != null) {
                player.updateMousePosition(mouseX, mouseY);
            }
        });
        
        gameCanvas.setOnMouseClicked(e -> {
            switch (e.getButton()) {
                case PRIMARY:
                    // Left click - fire projectile
                    firePlayerProjectile();
                    break;
                    
                case SECONDARY:
                    // Right click - activate special ability (not implemented yet)
                    break;
                    
                default:
                    // Other mouse buttons not used
                    break;
            }
        });
        
        // Make sure the canvas can receive key events
        gameCanvas.setFocusTraversable(true);
    }

    private void attackEnemiesInRange() {
        // Find enemies in melee range and damage them
        double meleeRange = 50; // Melee attack range
        for (Enemy enemy : enemies) {
            if (isInMeleeRange(player, enemy)) {
                // Apply melee damage
                double meleeDamage = 20;
                enemy.takeDamage(meleeDamage);
                
                // Show damage text
                effectsManager.showFloatingText("-" + (int)meleeDamage, 
                    enemy.getPosition(), Color.ORANGE);
            }
        }
    }

    private boolean isInMeleeRange(Player player, Enemy enemy) {
        double distance = player.getPosition().distance(enemy.getPosition());
        return distance <= player.getMeleeRange();
    }

    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        
        // Populate room based on its type
        switch (room.getType()) {
            case COMBAT:
                spawnEnemies(room);
                spawnItems(room);
                break;
            case PUZZLE:
                placeKeyInRoom(room);
                spawnItems(room);
                break;
            case TREASURE:
                spawnItems(room);
                break;
            case BOSS:
                spawnBoss(room);
                break;
            default:
                break;
        }
    }

    private void spawnEnemies(DungeonRoom room) {
        Random random = new Random();
        int enemyCount = random.nextInt(3) + 1; // Random number of enemies (1-3)
        
        for (int i = 0; i < enemyCount; i++) {
            // Randomly select an enemy type
            Enemy.EnemyType enemyType = Enemy.EnemyType.values()[random.nextInt(Enemy.EnemyType.values().length)];
            
            // Create enemy instance
            Enemy enemy = Enemy.createEnemy(enemyType);
            
            // Set enemy position within the room
            double x = random.nextDouble() * (gameCanvas.getWidth() - enemy.getWidth());
            double y = random.nextDouble() * (gameCanvas.getHeight() - enemy.getHeight());
            enemy.setPosition(x, y);
            
            // Add enemy to the list
            enemies.add(enemy);
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Spawn potions
        itemCount = random.nextInt(3) + 1; // Random number of potions (1-3)
        for (int i = 0; i < itemCount; i++) {
            Item potion = new Item(Item.ItemType.POTION, "Health Potion");
            double x = random.nextDouble() * (gameCanvas.getWidth() - potion.getSize());
            double y = random.nextDouble() * (gameCanvas.getHeight() - potion.getSize());
            potion.setPosition(x, y);
            roomItems.add(potion);
        }
        
        // Spawn weapons
        itemCount = random.nextInt(2) + 1; // Random number of weapons (1-2)
        for (int i = 0; i < itemCount; i++) {
            Item weapon = new Item(Item.ItemType.WEAPON, "Sword");
            double x = random.nextDouble() * (gameCanvas.getWidth() - weapon.getSize());
            double y = random.nextDouble() * (gameCanvas.getHeight() - weapon.getSize());
            weapon.setPosition(x, y);
            roomItems.add(weapon);
        }
        
        // Spawn armor
        itemCount = random.nextInt(2) + 1; // Random number of armor (1-2)
        for (int i = 0; i < itemCount; i++) {
            Item armor = new Item(Item.ItemType.ARMOR, "Armor");
            double x = random.nextDouble() * (gameCanvas.getWidth() - armor.getSize());
            double y = random.nextDouble() * (gameCanvas.getHeight() - armor.getSize());
            armor.setPosition(x, y);
            roomItems.add(armor);
        }
    }

    private void placeKeyInRoom(DungeonRoom room) {
        // Place a key in the room
        Item key = new Item(Item.ItemType.KEY, "Key");
        double x = random.nextDouble() * (gameCanvas.getWidth() - key.getSize());
        double y = random.nextDouble() * (gameCanvas.getHeight() - key.getSize());
        key.setPosition(x, y);
        roomItems.add(key);
    }

    private void spawnBoss(DungeonRoom room) {
        // Spawn the boss enemy
        Enemy boss = Enemy.createEnemy(Enemy.EnemyType.BOSS);
        double x = gameCanvas.getWidth() / 2 - boss.getWidth() / 2;
        double y = gameCanvas.getHeight() / 2 - boss.getHeight() / 2;
        boss.setPosition(x, y);
        enemies.add(boss);
    }

    private void createDoors() {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors - currentRoom is null");
            return;
        }
        
        // Clear existing doors
        doors.clear();
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : currentRoom.getConnectedRooms()) {
            Door door = createDoorForRoom(connectedRoom);
            if (door != null) {
                doors.add(door);
            }
        }
        
        // Debug output
        if (doors.isEmpty()) {
            System.out.println("No doors created for room: " + currentRoom);
        } else {
            System.out.println("Created " + doors.size() + " doors for room: " + currentRoom);
        }
    }

    private Door createDoorForRoom(DungeonRoom connectedRoom) {
        if (connectedRoom == null) {
            System.err.println("ERROR: Cannot create door for null room");
            return null;
        }
        
        // Determine door position based on room connection
        double x = 0, y = 0;
        double width = DOOR_WIDTH, height = DOOR_HEIGHT;
        
        if (currentRoom.getX() < connectedRoom.getX()) {
            // East door
            x = gameCanvas.getWidth() - ROOM_PADDING - width;
            y = (gameCanvas.getHeight() - height) / 2;
        } else if (currentRoom.getX() > connectedRoom.getX()) {
            // West door
            x = ROOM_PADDING;
            y = (gameCanvas.getHeight() - height) / 2;
        } else if (currentRoom.getY() < connectedRoom.getY()) {
            // South door
            x = (gameCanvas.getWidth() - width) / 2;
            y = gameCanvas.getHeight() - ROOM_PADDING - height;
        } else if (currentRoom.getY() > connectedRoom.getY()) {
            // North door
            x = (gameCanvas.getWidth() - width) / 2;
            y = ROOM_PADDING;
        }
        
        // Create door instance
        Door door = new Door(x, y, width, height, connectedRoom);
        
        // Set door lock state based on room types
        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE || 
            connectedRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            door.setLocked(true);
            door.setRequiresKey(true);
        } else {
            door.setLocked(false);
        }
        
        return door;
    }

    /**
     * Sets the current game level
     * @param level The new level value
     */
    public void setLevel(int level) {
        this.currentLevel = level;
        System.out.println("Setting game level to: " + level);
    }
    
    /**
     * Called when a puzzle is solved in a puzzle room
     * @param room The room containing the solved puzzle
     */
    public void onPuzzleSolved(DungeonRoom room) {
        // Mark the puzzle as solved
        if (puzzles.containsKey(room)) {
            puzzles.get(room).setSolved(true);
        }
        
        // Unlock the room
        room.setLocked(false);
        
        // Unlock connected doors
        for (Door door : doors) {
            if (door.getConnectedRoom() == room) {
                door.setLocked(false);
            }
        }
        
        // Show feedback to the player
        showFloatingText("Puzzle solved!", player.getPosition());
        
        // Award the player some points
        player.addScore(200);
        
        // Update puzzle completion flag
        puzzleCompleted = true;
    }
}
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
                gc.fillRect(door.getX(), door.getY(), door.getWidth(), door.getHeight());
                
                // Add door frame
                gc.setStroke(Color.DARKGRAY);
                gc.setLineWidth(3);
                gc.strokeRect(door.getX() - 2, door.getY() - 2, door.getWidth() + 4, door.getHeight() + 4);
                
                // Add door handle
                gc.setFill(Color.GOLD);
                gc.fillOval(
                    door.getX() + door.getWidth() * 0.8, 
                    door.getY() + door.getHeight() / 2, 
                    5, 
                    5
                );
                
                // Draw key icon if door requires key
                if (door.requiresKey()) {
                    gc.setFill(Color.YELLOW);
                    gc.fillOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                    gc.setStroke(Color.BLACK);
                    gc.setLineWidth(1);
                    gc.strokeOval(
                        door.getX() + door.getWidth() / 2 - 7,
                        door.getY() + door.getHeight() / 2 - 7,
                        14, 14
                    );
                }
                
                // Display the connected room type
                if (isDebugMode) {
                    String roomTypeText = door.getConnectedRoom().getType().toString();
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(roomTypeText, 
                        door.getX() + door.getWidth() / 2 - 20,
                        door.getY() + door.getHeight() + 15);
                }
            }
        }
        
        // Draw room items
        for (Item item : roomItems) {
            // Draw item as a circle with color based on type
            gc.setFill(getItemColor(item.getType()));
            gc.fillOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item outline
            gc.setStroke(Color.BLACK);
            gc.setLineWidth(1);
            gc.strokeOval(item.getX() - item.getSize()/2, item.getY() - item.getSize()/2, 
                        item.getSize(), item.getSize());
            
            // Draw item name for debug or when player is close
            if (isDebugMode || (player != null && 
                player.getPosition().distance(new Point2D(item.getX(), item.getY())) < 100)) {
                gc.setFill(Color.WHITE);
                gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                gc.fillText(item.getName(), item.getX() - 20, item.getY() - 10);
            }
        }
        
        // Draw enemies
        if (enemies.isEmpty()) {
            System.out.println("No enemies to render in current room");
        } else {
            System.out.println("Rendering " + enemies.size() + " enemies");
            for (Enemy enemy : enemies) {
                System.out.println("Rendering enemy at: " + enemy.getX() + "," + enemy.getY() + " of type: " + enemy.getType());
                // Draw enemy as a red rectangle
                if (enemy.getType() == Enemy.EnemyType.BOSS) {
                    gc.setFill(Color.DARKRED);
                    // Draw boss larger
                    gc.fillRect(enemy.getX() - 5, enemy.getY() - 5, enemy.getSize() + 10, enemy.getSize() + 10);
                } else {
                    gc.setFill(Color.RED);
                    gc.fillRect(enemy.getX(), enemy.getY(), enemy.getSize(), enemy.getSize());
                }
                
                // Draw enemy health bar
                double healthPercentage = (double) enemy.getHealth() / enemy.getMaxHealth();
                double healthBarWidth = enemy.getSize() * healthPercentage;
                
                gc.setFill(Color.BLACK);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, enemy.getSize(), 5);
                gc.setFill(Color.GREEN);
                gc.fillRect(enemy.getX(), enemy.getY() - 8, healthBarWidth, 5);
                
                // Draw enemy type if debug mode is on
                if (isDebugMode) {
                    gc.setFill(Color.WHITE);
                    gc.setFont(Font.font("Verdana", FontWeight.NORMAL, 10));
                    gc.fillText(enemy.getType().toString(), enemy.getX(), enemy.getY() - 12);
                }
            }
        }
        
        // Draw player projectiles
        for (ProjectileAttack attack : playerProjectiles) {
            attack.render(gc);
        }
        
        // Draw projectiles
        for (Projectile projectile : projectiles) {
            projectile.render(gc);
        }
        
        // Draw the player
        if (player != null) {
            player.render(gc);
        }
        
        // Draw UI elements
        renderUI(gc);
    }
    
    private void drawPauseButton(GraphicsContext gc) {
        // Draw pause button in top-right corner
        double buttonSize = 30;
        double padding = 10;
        double x = gameCanvas.getWidth() - buttonSize - padding;
        double y = padding;
        
        // Draw button background
        gc.setFill(Color.DARKGRAY);
        gc.fillRoundRect(x, y, buttonSize, buttonSize, 5, 5);
        
        // Draw pause icon
        gc.setFill(Color.WHITE);
        gc.fillRect(x + buttonSize * 0.3, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        gc.fillRect(x + buttonSize * 0.55, y + buttonSize * 0.25, buttonSize * 0.15, buttonSize * 0.5);
        
        // Draw button border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRoundRect(x, y, buttonSize, buttonSize, 5, 5);
    }
    
    private void drawRoomBackground(GraphicsContext gc) {
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot draw room background - currentRoom is null");
            gc.setFill(Color.BLACK);
            gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
            return;
        }
        
        System.out.println("Drawing background for room type: " + currentRoom.getType());
        
        // Set the base background color based on room type
        Color baseColor;
        switch (currentRoom.getType()) {
            case SPAWN:
                baseColor = Color.rgb(0, 80, 0); // Dark green for spawn
                break;
            case COMBAT:
                baseColor = Color.rgb(70, 30, 30); // Dark red for combat
                break;
            case PUZZLE:
                baseColor = Color.rgb(30, 30, 80); // Dark blue for puzzle
                break;
            case TREASURE:
                baseColor = Color.rgb(80, 80, 30); // Gold for treasure
                break;
            case BOSS:
                baseColor = Color.rgb(80, 0, 0); // Deep red for boss
                break;
            default:
                baseColor = Color.rgb(30, 30, 30); // Dark gray default
                break;
        }
        
        // Fill the entire canvas with the base color
        gc.setFill(baseColor);
        gc.fillRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw floor tiles based on room type
        double tileSize = 40;
        
        switch (currentRoom.getType()) {
            case COMBAT:
                drawCombatRoomFloor(gc, tileSize);
                break;
            case PUZZLE:
                drawPuzzleRoomFloor(gc, tileSize);
                break;
            case TREASURE:
                drawTreasureRoomFloor(gc, tileSize);
                break;
            case BOSS:
                drawBossRoomFloor(gc, tileSize);
                break;
            case SPAWN:
            default:
                drawSpawnRoomFloor(gc, tileSize);
                break;
        }
        
        // Draw room borders
        gc.setStroke(Color.DARKGRAY);
        gc.setLineWidth(5);
        gc.strokeRect(10, 10, gameCanvas.getWidth() - 20, gameCanvas.getHeight() - 20);
    }
    
    private void drawCombatRoomFloor(GraphicsContext gc, double tileSize) {
        // Checkered pattern in dark red
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(60, 20, 20));
                } else {
                    gc.setFill(Color.rgb(40, 10, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add some blood stains
        gc.setFill(Color.rgb(120, 0, 0, 0.3));
        for (int i = 0; i < 10; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 20 + random.nextDouble() * 30;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawPuzzleRoomFloor(GraphicsContext gc, double tileSize) {
        // Blue tiled pattern with symbols
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(20, 30, 50));
                gc.fillRect(x, y, tileSize, tileSize);
                
                // Add tile borders
                gc.setStroke(Color.rgb(30, 40, 70));
                gc.strokeRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add arcane symbols
        gc.setFill(Color.rgb(100, 150, 255, 0.2));
        for (int i = 0; i < 8; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 30 + random.nextDouble() * 40;
            
            // Draw a random arcane symbol (simplified)
            double angle = random.nextDouble() * Math.PI * 2;
            double[] xPoints = new double[5];
            double[] yPoints = new double[5];
            
            for (int j = 0; j < 5; j++) {
                xPoints[j] = x + Math.cos(angle + j * Math.PI * 2 / 5) * size / 2;
                yPoints[j] = y + Math.sin(angle + j * Math.PI * 2 / 5) * size / 2;
            }
            
            gc.fillPolygon(xPoints, yPoints, 5);
        }
    }
    
    private void drawTreasureRoomFloor(GraphicsContext gc, double tileSize) {
        // Gold/yellow tiled pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(80, 70, 20));
                } else {
                    gc.setFill(Color.rgb(60, 50, 10));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add gold coins scattered around
        gc.setFill(Color.GOLD);
        for (int i = 0; i < 30; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double size = 3 + random.nextDouble() * 5;
            gc.fillOval(x, y, size, size);
        }
    }
    
    private void drawBossRoomFloor(GraphicsContext gc, double tileSize) {
        // Dark pattern with lava cracks
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                gc.setFill(Color.rgb(30, 10, 10));
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
        
        // Add lava cracks
        gc.setFill(Color.rgb(255, 50, 0, 0.7));
        for (int i = 0; i < 15; i++) {
            double x = random.nextDouble() * gameCanvas.getWidth();
            double y = random.nextDouble() * gameCanvas.getHeight();
            double width = 5 + random.nextDouble() * 100;
            double height = 3 + random.nextDouble() * 5;
            double angle = random.nextDouble() * Math.PI;
            
            gc.save();
            gc.translate(x, y);
            gc.rotate(Math.toDegrees(angle));
            gc.fillRect(-width/2, -height/2, width, height);
            gc.restore();
        }
    }
    
    private void drawSpawnRoomFloor(GraphicsContext gc, double tileSize) {
        // Green/brown natural pattern
        for (int x = 0; x < gameCanvas.getWidth(); x += tileSize) {
            for (int y = 0; y < gameCanvas.getHeight(); y += tileSize) {
                if ((x / tileSize + y / tileSize) % 2 == 0) {
                    gc.setFill(Color.rgb(30, 50, 30));
                } else {
                    gc.setFill(Color.rgb(40, 60, 40));
                }
                gc.fillRect(x, y, tileSize, tileSize);
            }
        }
    }
    
    private void updateLighting() {
        if (lightingEffect == null) {
            return;
        }
        
        // Clear previous lights
        lightingEffect.clearLights();
        
        // Set ambient light based on room type
        switch (currentRoom.getType()) {
            case COMBAT:
                lightingEffect.setAmbientLight(0.3); // Dim red lighting
                break;
                
            case PUZZLE:
                lightingEffect.setAmbientLight(0.4); // Moderate blue lighting
                break;
                
            case TREASURE:
                lightingEffect.setAmbientLight(0.5); // Brighter gold lighting
                break;
                
            case BOSS:
                lightingEffect.setAmbientLight(0.2); // Very dark with red tint
                break;
                
            case SPAWN:
            default:
                lightingEffect.setAmbientLight(0.6); // Bright natural lighting
                break;
        }
        
        // Add player light
        lightingEffect.addLightSource(
            player.getPosition(), 
            150, 
            Color.WHITE, 
            LightingEffect.LightSource.LightType.FLICKERING
        );
        
        // Add door lights
        for (Door door : doors) {
            Color lightColor = door.isLocked() ? Color.RED : Color.GREEN;
            lightingEffect.addLightSource(
                new Point2D(door.getX() + door.getWidth()/2, door.getY() + door.getHeight()/2),
                60,
                lightColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add item lights
        for (Item item : roomItems) {
            Color itemColor = getItemColor(item.getType());
            lightingEffect.addLightSource(
                new Point2D(item.getX(), item.getY()),
                item.getSize() * 3,
                itemColor,
                LightingEffect.LightSource.LightType.PULSING
            );
        }
        
        // Add enemy lights
        for (Enemy enemy : enemies) {
            Color enemyColor = Color.RED;
            if (enemy.getType() == Enemy.EnemyType.BOSS) {
                enemyColor = Color.DARKRED;
            } else if (enemy.getType() == Enemy.EnemyType.MAGE) {
                enemyColor = Color.BLUE;
            }
            
            lightingEffect.addLightSource(
                enemy.getPosition(),
                enemy.getSize() * 2,
                enemyColor,
                enemy.getType() == Enemy.EnemyType.BOSS ? 
                    LightingEffect.LightSource.LightType.PULSING : 
                    LightingEffect.LightSource.LightType.FLICKERING
            );
        }
        
        // Add environmental lights based on room type
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
            // Add lava lights for boss room
            for (int i = 0; i < 5; i++) {
                double x = random.nextDouble() * gameCanvas.getWidth();
                double y = random.nextDouble() * gameCanvas.getHeight();
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    30 + random.nextDouble() * 50,
                    Color.ORANGE,
                    LightingEffect.LightSource.LightType.FLICKERING
                );
            }
        } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
            // Add arcane lights for puzzle room
            for (int i = 0; i < 4; i++) {
                double x = 100 + i * (gameCanvas.getWidth() - 200) / 3;
                double y = gameCanvas.getHeight() / 2;
                lightingEffect.addLightSource(
                    new Point2D(x, y),
                    70,
                    Color.CYAN,
                    LightingEffect.LightSource.LightType.PULSING
                );
            }
        }
    }
    
    private void renderUI(GraphicsContext gc) {
        if (player == null) return;
        
        // Set up fonts
        Font titleFont = Font.font("Arial", FontWeight.BOLD, 16);
        Font normalFont = Font.font("Arial", FontWeight.NORMAL, 14);
        
        // Draw player health bar
        double healthBarWidth = 200;
        double healthBarHeight = 20;
        double healthPercentage = (double) player.getHealth() / player.getMaxHealth();
        
        // Health bar background
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health bar fill
        Color healthColor;
        if (healthPercentage > 0.7) {
            healthColor = Color.GREEN;
        } else if (healthPercentage > 0.3) {
            healthColor = Color.YELLOW;
        } else {
            healthColor = Color.RED;
        }
        
        gc.setFill(healthColor);
        gc.fillRect(20, 20, healthBarWidth * healthPercentage, healthBarHeight);
        
        // Health bar border
        gc.setStroke(Color.BLACK);
        gc.setLineWidth(2);
        gc.strokeRect(20, 20, healthBarWidth, healthBarHeight);
        
        // Health text
        gc.setFill(Color.WHITE);
        gc.setFont(normalFont);
        gc.fillText("HP: " + (int)player.getHealth() + "/" + (int)player.getMaxHealth(), 
                    25, 36);
        
        // Draw current weapon info
        String weaponText = "Weapon: " + player.getCurrentWeapon().getType().getName();
        gc.fillText(weaponText, 20, 60);
        
        // Draw score
        gc.setFont(normalFont);
        gc.fillText("Score: " + player.getScore(), 20, 80);
        
        // Draw enemy count
        gc.fillText("Enemies: " + enemies.size(), 20, 100);
        
        // Draw level info
        gc.fillText("Level: " + currentLevel, 20, 120);
        
        // Draw current room type
        String roomTypeText = "Room: " + (currentRoom != null ? currentRoom.getType().toString() : "UNKNOWN");
        gc.fillText(roomTypeText, 20, 140);
        
        // Draw mini-map in top-right corner if needed
        if (isDebugMode) {
            drawMiniMap(gc);
        }
        
        // Draw FPS counter in debug mode
        if (isDebugMode) {
            long currentTime = System.nanoTime();
            double fps = 1_000_000_000.0 / (currentTime - lastUpdateTime);
            gc.fillText(String.format("FPS: %.1f", fps), gameCanvas.getWidth() - 100, 20);
        }
        
        // Controls reminder at the bottom
        gc.setFill(Color.LIGHTBLUE);
        gc.fillText("WASD: Move | Mouse: Aim | Left Click: Shoot | Space: Melee | ESC: Pause", 
                   gameCanvas.getWidth() / 2 - 200, gameCanvas.getHeight() - 20);
    }

    private void drawMiniMap(GraphicsContext gc) {
        // Mini-map settings
        double mapSize = 150;
        double mapX = gameCanvas.getWidth() - mapSize - 20;
        double mapY = 20;
        double cellSize = 10;
        
        // Draw mini-map background
        gc.setFill(Color.rgb(0, 0, 0, 0.7));
        gc.fillRect(mapX, mapY, mapSize, mapSize);
        
        // Draw mini-map border
        gc.setStroke(Color.WHITE);
        gc.setLineWidth(1);
        gc.strokeRect(mapX, mapY, mapSize, mapSize);
        
        // Find min/max coordinates to center the map
        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;
        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;
        
        for (DungeonRoom room : currentDungeon) {
            minX = Math.min(minX, room.getX());
            minY = Math.min(minY, room.getY());
            maxX = Math.max(maxX, room.getX());
            maxY = Math.max(maxY, room.getY());
        }
        
        // Calculate scaling to fit all rooms
        int mapWidth = maxX - minX + 1;
        int mapHeight = maxY - minY + 1;
        double scaleX = mapSize / (mapWidth * 1.5);
        double scaleY = mapSize / (mapHeight * 1.5);
        double scale = Math.min(scaleX, scaleY);
        
        // Calculate offset to center the map
        double offsetX = mapX + (mapSize - mapWidth * scale) / 2;
        double offsetY = mapY + (mapSize - mapHeight * scale) / 2;
        
        // Draw rooms
        for (DungeonRoom room : currentDungeon) {
            double roomX = offsetX + (room.getX() - minX) * scale;
            double roomY = offsetY + (room.getY() - minY) * scale;
            
            // Choose color based on room type
            Color roomColor;
            switch (room.getType()) {
                case SPAWN:
                    roomColor = Color.GREEN;
                    break;
                case BOSS:
                    roomColor = Color.RED;
                    break;
                case PUZZLE:
                    roomColor = Color.BLUE;
                    break;
                case TREASURE:
                    roomColor = Color.GOLD;
                    break;
                default:
                    roomColor = Color.GRAY;
            }
            
            // Draw room
            gc.setFill(room.isVisited() ? roomColor : Color.DARKGRAY);
            gc.fillRect(roomX, roomY, scale * 0.8, scale * 0.8);
            
            // If this is the current room, highlight it
            if (room == currentRoom) {
                gc.setStroke(Color.WHITE);
                gc.setLineWidth(2);
                gc.strokeRect(roomX, roomY, scale * 0.8, scale * 0.8);
            }
        }
        
        // Draw minimap legend
        double legendX = mapX + 10;
        double legendY = mapY + mapSize + 10;
        double legendBoxSize = 8;
        double textOffset = 15;
        
        gc.setFont(Font.font("Arial", FontWeight.NORMAL, 10));
        
        // Current room
        gc.setFill(Color.WHITE);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.fillText("Current", legendX + legendBoxSize + 5, legendY + 8);
        
        // Spawn room
        legendY += textOffset;
        gc.setFill(Color.GREEN);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Spawn", legendX + legendBoxSize + 5, legendY + 8);
        
        // Boss room
        legendY += textOffset;
        gc.setFill(Color.RED);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Boss", legendX + legendBoxSize + 5, legendY + 8);
        
        // Unvisited room
        legendY += textOffset;
        gc.setFill(Color.DARKGRAY);
        gc.fillRect(legendX, legendY, legendBoxSize, legendBoxSize);
        gc.setFill(Color.WHITE);
        gc.fillText("Unexplored", legendX + legendBoxSize + 5, legendY + 8);
    }

    public Player getPlayer() {
        return player;
    }

    private Color getItemColor(Item.ItemType type) {
        switch (type) {
            case WEAPON: return Color.RED;
            case POTION: return Color.GREEN;
            case ARMOR: return Color.BLUE;
            default: return Color.WHITE;
        }
    }

    private void createDoors() {
        // First remove existing doors
        doors.clear();
        
        if (currentRoom == null) {
            System.err.println("ERROR: Cannot create doors for null room");
            return;
        }
        
        System.out.println("Creating doors for room " + currentRoom.getType() + 
                          " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")");
        
        List<DungeonRoom> connectedRooms = currentRoom.getConnectedRooms();
        System.out.println("Connected rooms: " + connectedRooms.size());
        
        if (connectedRooms.isEmpty()) {
            System.err.println("WARNING: Room has no connected rooms!");
            return;
        }
        
        // Determine room bounds on the canvas
        double roomWidth = gameCanvas.getWidth() - 100;  // 50px margin on each side
        double roomHeight = gameCanvas.getHeight() - 100;
        double doorWidth = DOOR_WIDTH;
        double doorHeight = DOOR_HEIGHT;
        
        // Create doors for each connected room
        for (DungeonRoom connectedRoom : connectedRooms) {
            if (connectedRoom == null) {
                System.err.println("WARNING: Connected room is null!");
                continue;
            }
            
            // Determine direction to the connected room
            int dx = connectedRoom.getX() - currentRoom.getX();
            int dy = connectedRoom.getY() - currentRoom.getY();
            
            System.out.println("Adding door to " + connectedRoom.getType() + 
                              " at direction (" + dx + "," + dy + ")");
            
            // Calculate door position based on direction
            double doorX, doorY;
            Door.DoorDirection doorDirection;
            
            if (dx > 0) {      // East door
                doorX = roomWidth - doorWidth + 50;
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.EAST;
            } else if (dx < 0) { // West door
                doorX = 50;  // Left margin
                doorY = (roomHeight / 2) - (doorHeight / 2) + 50;
                doorDirection = Door.DoorDirection.WEST;
            } else if (dy > 0) { // South door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = roomHeight - doorHeight + 50;
                doorDirection = Door.DoorDirection.SOUTH;
            } else {            // North door
                doorX = (roomWidth / 2) - (doorWidth / 2) + 50;
                doorY = 50;  // Top margin
                doorDirection = Door.DoorDirection.NORTH;
            }
            
            // Create the door
            Door door = new Door(
                doorX, doorY, doorWidth, doorHeight,
                currentRoom, connectedRoom, doorDirection
            );
            
            // Lock doors based on room type
            if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT ||
                currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                // Combat rooms: doors are locked until enemies are defeated
                door.setLocked(!enemies.isEmpty());
                System.out.println("Combat/Boss room door locked state: " + door.isLocked() + 
                                 " (enemies: " + enemies.size() + ")");
            } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                // Puzzle rooms: doors are locked until puzzle is solved
                door.setLocked(!puzzleCompleted);
                door.setRequiresKey(true);
                System.out.println("Puzzle room door locked state: " + door.isLocked() + 
                                 " (puzzle completed: " + puzzleCompleted + ")");
            }
            
            doors.add(door);
            System.out.println("Added door at " + doorX + "," + doorY + 
                              " to " + connectedRoom.getType() + 
                              " (locked: " + door.isLocked() + ", requires key: " + door.requiresKey() + ")");
        }
        
        // Debug output of created doors
        if (doors.isEmpty()) {
            System.err.println("WARNING: No doors were created!");
        } else {
            System.out.println("Created " + doors.size() + " doors");
        }
    }
    
    private void populateRoom(DungeonRoom room) {
        // Clear existing entities
        enemies.clear();
        roomItems.clear();
        roomCleared = false;
        
        System.out.println("Populating room of type: " + room.getType() + " at position " + room.getX() + "," + room.getY());
        
        // Get room center
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        Point2D roomCenter = new Point2D(centerX, centerY);
        
        switch (room.getType()) {
            case COMBAT:
                // Add enemies in combat rooms
                spawnEnemiesForRoom(room, false);
                
                // Add a health potion
                if (new Random().nextDouble() < 0.5) {
                    spawnBasicItem(roomCenter.add(50, 50));
                    System.out.println("Added health potion to combat room");
                }
                break;
                
            case BOSS:
                // Add boss enemy with enhanced spawning
                spawnEnemiesForRoom(room, true);
                break;
                
            case TREASURE:
                // Add random items
                System.out.println("Spawning items in treasure room");
                Random rnd = new Random();
                int itemCount = 2 + rnd.nextInt(3); // 2-4 items
                
                for (int i = 0; i < itemCount; i++) {
                    double angle = rnd.nextDouble() * Math.PI * 2; // Random angle
                    double distance = 50 + rnd.nextDouble() * 100; // Distance from center
                    
                    double offsetX = Math.cos(angle) * distance;
                    double offsetY = Math.sin(angle) * distance;
                    
                    spawnBasicItem(roomCenter.add(offsetX, offsetY));
                }
                break;
                
            case PUZZLE:
                // Add a key
                System.out.println("Adding key to puzzle room");
                placeKeyInRoom(room);
                break;
                
            case SPAWN:
            default:
                // No special spawns in spawn room
                break;
        }
        
        // Create doors for the new room
        createDoors();
    }
    
    /**
     * Enhanced enemy spawning system for rooms
     */
    private void spawnEnemiesForRoom(DungeonRoom room, boolean isBossRoom) {
        Random random = new Random();
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        if (isBossRoom) {
            System.out.println("Spawning boss in boss room");
            // Create a boss enemy
            Enemy bossEnemy = new Enemy(centerX, centerY, Enemy.EnemyType.BOSS);
            
            // Double the boss's max health and increase damage
            bossEnemy.setMaxHealth(bossEnemy.getMaxHealth() * 2);
            bossEnemy.heal(bossEnemy.getMaxHealth()); // Heal to full health
            
            // Add the boss
            enemies.add(bossEnemy);
            
            // Add minions around the boss
            int minionCount = 1 + random.nextInt(2); // 1-2 minions
            for (int i = 0; i < minionCount; i++) {
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 120 + random.nextInt(50);
                
                double enemyX = centerX + Math.cos(angle) * distance;
                double enemyY = centerY + Math.sin(angle) * distance;
                
                // Keep within bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Create a minion (using the constructor with behavior parameter)
                Enemy minion = new Enemy(enemyX, enemyY, Enemy.EnemyType.SKELETON, Enemy.BehaviorType.AGGRESSIVE, 1);
                enemies.add(minion);
            }
            
            System.out.println("Spawned boss with " + minionCount + " minions");
        } else {
            // Regular combat room
            int playerLevel = player != null ? player.getLevel() : 1;
            int roomDepth = Math.abs(room.getX()) + Math.abs(room.getY());
            
            // Adjust enemy count based on player level and room distance from spawn
            int baseEnemyCount = 2;
            int levelBonus = (playerLevel - 1) / 2; // Every 2 levels adds an enemy
            int depthBonus = roomDepth / 3; // Every 3 rooms deeper adds an enemy
            int maxEnemyCount = Math.min(6, baseEnemyCount + levelBonus + depthBonus);
            int enemyCount = baseEnemyCount + random.nextInt(maxEnemyCount - baseEnemyCount + 1);
            
            System.out.println("Spawning " + enemyCount + " enemies in combat room (player level: " + 
                              playerLevel + ", room depth: " + roomDepth + ")");
            
            // Determine possible enemy types based on depth
            List<Enemy.EnemyType> possibleTypes = new ArrayList<>();
            possibleTypes.add(Enemy.EnemyType.GOBLIN);  // Always available
            
            if (roomDepth > 1 || playerLevel > 1) {
                possibleTypes.add(Enemy.EnemyType.SKELETON);
            }
            
            if (roomDepth > 3 || playerLevel > 3) {
                possibleTypes.add(Enemy.EnemyType.ORC);
            }
            
            if (roomDepth > 5 || playerLevel > 5) {
                possibleTypes.add(Enemy.EnemyType.MAGE);
            }
            
            // Spawn enemies
            for (int i = 0; i < enemyCount; i++) {
                // Calculate random position within the room, away from center
                double angle = random.nextDouble() * Math.PI * 2;
                double distance = 100 + random.nextDouble() * 150;
                
                double offsetX = Math.cos(angle) * distance;
                double offsetY = Math.sin(angle) * distance;
                
                double enemyX = centerX + offsetX;
                double enemyY = centerY + offsetY;
                
                // Keep enemies within room bounds
                enemyX = Math.max(50, Math.min(gameCanvas.getWidth() - 50, enemyX));
                enemyY = Math.max(50, Math.min(gameCanvas.getHeight() - 50, enemyY));
                
                // Randomly select an enemy type from the available options
                Enemy.EnemyType type = possibleTypes.get(random.nextInt(possibleTypes.size()));
                
                // Determine behavior type
                Enemy.BehaviorType behaviorType;
                double behaviorRand = random.nextDouble();
                if (behaviorRand < 0.6) {
                    behaviorType = Enemy.BehaviorType.AGGRESSIVE;
                } else if (behaviorRand < 0.8) {
                    behaviorType = Enemy.BehaviorType.RANGED;
                } else if (behaviorRand < 0.9) {
                    behaviorType = Enemy.BehaviorType.PATROLLER;
                } else {
                    behaviorType = Enemy.BehaviorType.AMBUSHER;
                }
                
                // Create enemy with the determined behavior type
                Enemy enemy = new Enemy(enemyX, enemyY, type, behaviorType, 1);
                
                // Scale enemy based on room depth and player level
                if (roomDepth > 2 || playerLevel > 2) {
                    double healthMultiplier = 1.0 + (roomDepth * 0.1) + ((playerLevel - 1) * 0.05);
                    enemy.setMaxHealth(enemy.getMaxHealth() * healthMultiplier);
                    enemy.heal(enemy.getMaxHealth()); // Set to full health
                }
                
                enemies.add(enemy);
                System.out.println("Added enemy at " + enemyX + "," + enemyY + " of type: " + type + 
                                  ", behavior: " + enemy.getBehavior());
            }
        }
    }

    private void spawnItems(DungeonRoom room) {
        Random random = new Random();
        int itemCount = 0;
        
        // Determine number of items based on room type
        switch (room.getType()) {
            case COMBAT:
                itemCount = random.nextInt(2); // 0-1 items
                break;
            case PUZZLE:
                itemCount = 1; // Always spawn a key
                // Add a key to unlock doors
                placeKeyInRoom(room);
                break;
            case TREASURE:
                itemCount = random.nextInt(3) + 2; // 2-4 items
                break;
            case BOSS:
                itemCount = random.nextInt(2) + 1; // 1-2 special items
                break;
            case SPAWN:
                // No items in spawn room
                return;
        }
        
        // Add random items
        for (int i = 0; i < itemCount; i++) {
            addItemToRoom(room);
        }
    }
    
    private void placeKeyInRoom(DungeonRoom room) {
        // Get the center of the room on the canvas
        double centerX = gameCanvas.getWidth() / 2;
        double centerY = gameCanvas.getHeight() / 2;
        
        // Add some randomness to key position
        Random random = new Random();
        double keyX = centerX + (random.nextDouble() - 0.5) * 100;
        double keyY = centerY + (random.nextDouble() - 0.5) * 100;
        
        // Create and add the key
        Item roomKey = new Item("Room Key", "Opens locked doors", Item.ItemType.KEY, 1, true);
        roomKey.setX(keyX);
        roomKey.setY(keyY);
        roomKey.setSize(20);
        
        System.out.println("Added key at position: " + keyX + "," + keyY);
        roomItems.add(roomKey);
    }
    
    private void spawnBasicItem(Point2D position) {
        Random random = new Random();
        
        // Randomize item type
        Item.ItemType type;
        String name;
        String description;
        int value;
        boolean consumable;
        
        double rnd = random.nextDouble();
        if (rnd < 0.6) {
            // 60% chance for a potion
            type = Item.ItemType.POTION;
            name = "Health Potion";
            description = "Restores 20 health";
            value = 20;
            consumable = true;
        } else if (rnd < 0.8) {
            // 20% chance for a weapon
            type = Item.ItemType.WEAPON;
            name = "Sword";
            description = "A sharp weapon";
            value = 15;
            consumable = false;
        } else {
            // 20% chance for treasure
            type = Item.ItemType.TREASURE;
            name = "Gold Coins";
            description = "Valuable treasure";
            value = 50;
            consumable = true;
        }
        
        // Create the item
        Item item = new Item(name, description, type, value, consumable);
        item.setX(position.getX());
        item.setY(position.getY());
        item.setSize(20);
        
        System.out.println("Added item: " + name + " at " + position.getX() + "," + position.getY());
        
        roomItems.add(item);
    }
    
    private void spawnEnemy(DungeonRoom room) {
        Random random = new Random();
        Point2D roomPos = new Point2D(room.getX(), room.getY());
        Point2D randomOffset = new Point2D(
            random.nextDouble() * room.getWidth(),
            random.nextDouble() * room.getHeight()
        );
        Point2D spawnPos = roomPos.add(randomOffset).multiply(8); // Scale to pixel coordinates
        
        Enemy.EnemyType type = random.nextBoolean() ? Enemy.EnemyType.GOBLIN : Enemy.EnemyType.SKELETON;
        enemies.add(new Enemy(spawnPos.getX(), spawnPos.getY(), type));
    }

    private boolean isColliding(Entity entity1, Entity entity2) {
        Point2D center1 = entity1.getPosition().add(entity1.getSize() / 2, entity1.getSize() / 2);
        Point2D center2 = entity2.getPosition().add(entity2.getSize() / 2, entity2.getSize() / 2);
        double distance = center1.distance(center2);
        double combinedRadius = (entity1.getSize() + entity2.getSize()) / 2;
        return distance < combinedRadius;
    }

    private boolean isInMeleeRange(Entity attacker, Entity target) {
        double attackRange = 40; // Melee attack range
        
        Point2D attackerCenter = attacker.getPosition().add(new Point2D(attacker.getSize() / 2, attacker.getSize() / 2));
        Point2D targetCenter = target.getPosition().add(new Point2D(target.getSize() / 2, target.getSize() / 2));
        
        return attackerCenter.distance(targetCenter) < (attacker.getSize() / 2 + target.getSize() / 2 + attackRange);
    }

    private void showFloatingText(String text, Point2D position) {
        // This would be implemented with a UI element that floats up and fades out
        // For now, we'll just print to console
        System.out.println("Floating text at " + position + ": " + text);
    }

    private void dropRandomItem(Point2D position) {
        Random random = new Random();
        if (random.nextDouble() < 0.3) { // 30% chance to drop an item
            Item.ItemType type = Item.ItemType.values()[random.nextInt(Item.ItemType.values().length)];
            String name;
            String description;
            int value;
            boolean consumable;
            
            switch (type) {
                case WEAPON:
                    name = "Sword";
                    description = "A sharp blade";
                    value = 10;
                    consumable = false;
                    break;
                case POTION:
                    name = "Health Potion";
                    description = "Restores 20 HP";
                    value = 20;
                    consumable = true;
                    break;
                case ARMOR:
                    name = "Shield";
                    description = "Provides protection";
                    value = 15;
                    consumable = false;
                    break;
                default:
                    name = "Gold Coins";
                    description = "Valuable treasure";
                    value = 50;
                    consumable = true;
                    type = Item.ItemType.TREASURE;
                    break;
            }
            
            // Create and add the item
            Item item = new Item(name, description, type, value, consumable);
            item.setX(position.getX());
            item.setY(position.getY());
            item.setSize(20);
            roomItems.add(item);
        }
    }

    private boolean isPlayerTouchingItem(Item item) {
        double playerCenterX = player.getPosition().getX() + player.getSize() / 2;
        double playerCenterY = player.getPosition().getY() + player.getSize() / 2;
        double itemCenterX = item.getX() + 5; // Assuming item size is 10x10
        double itemCenterY = item.getY() + 5;
        
        double distance = Math.sqrt(
            Math.pow(playerCenterX - itemCenterX, 2) + 
            Math.pow(playerCenterY - itemCenterY, 2)
        );
        
        return distance < (player.getSize() / 2 + 5); // Player radius + item radius
    }

    private void checkRoomTransition() {
        // Check if player is at a door to a connected room
        for (Door door : doors) {
            if (isPlayerTouchingDoor(door)) {
                System.out.println("Player touching door to " + door.getConnectedRoom().getType() + 
                                  " - Door locked: " + door.isLocked() + 
                                  ", Requires key: " + door.requiresKey());
                
                if (!door.isLocked()) {
                    // Get the connected room
                    DungeonRoom targetRoom = door.getConnectedRoom();
                    if (targetRoom != null) {
                        System.out.println("Door unlocked - transitioning to room: " + targetRoom.getType() + 
                                          " at position " + targetRoom.getX() + "," + targetRoom.getY());
                        
                        // Calculate entry position based on door direction
                        Point2D entryPosition = getEntryPosition(door);
                        
                        // Pass target room and entry position to transition method
                        transitionToRoom(targetRoom, entryPosition);
                        
                        // Update difficulty based on room type if it's a boss room
                        if (targetRoom.getType() == DungeonRoom.RoomType.BOSS) {
                            adjustDifficultyForLevel();
                        }
                        
                        break;
                    } else {
                        System.err.println("ERROR: Connected room is null!");
                    }
                } else {
                    // Show message about locked door if player is touching it
                    if (door.requiresKey()) {
                        effectsManager.showFloatingText("This door requires a key", 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.YELLOW);
                        
                        // Try to unlock with key if player has one
                        if (player.getInventory().hasItem(Item.ItemType.KEY)) {
                            if (door.unlock(player.getInventory())) {
                                effectsManager.showFloatingText("Door unlocked!", 
                                    new Point2D(door.getX() + door.getWidth()/2, door.getY() - 10),
                                    Color.GREEN);
                                // Door is now unlocked, but wait for next check to transition
                            }
                        }
                    } else {
                        // Door is locked for other reasons (enemies not defeated)
                        String message = "Defeat all enemies to unlock";
                        if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                            message = "Solve the puzzle to unlock";
                        }
                        effectsManager.showFloatingText(message, 
                            new Point2D(door.getX() + door.getWidth()/2, door.getY() - 20), 
                            Color.RED);
                    }
                }
            }
        }
    }

    private void transitionToRoom(DungeonRoom room) {
        if (roomTransitionInProgress || room == null) {
            System.out.println("Cannot transition to room: " + (room == null ? "null" : room.getType()) + 
                               ", transition in progress: " + roomTransitionInProgress);
            return;
        }
        
        System.out.println("Starting transition to " + room.getType() + " room at position " + room.getX() + "," + room.getY());
        roomTransitionInProgress = true;
        
        // Create a fade transition effect
        Rectangle fadeRect = new Rectangle(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        fadeRect.setFill(Color.BLACK);
        fadeRect.setOpacity(0);
        rootPane.getChildren().add(fadeRect);
        
        // Create fade out transition
        javafx.animation.FadeTransition fadeOut = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeOut.setFromValue(0);
        fadeOut.setToValue(1);
        
        // Create fade in transition
        javafx.animation.FadeTransition fadeIn = new javafx.animation.FadeTransition(Duration.seconds(TRANSITION_DURATION / 2), fadeRect);
        fadeIn.setFromValue(1);
        fadeIn.setToValue(0);
        
        // Add visual effects for room transition
        effectsManager.addRoomTransitionEffect();
        
        // Set up the sequence
        fadeOut.setOnFinished(e -> {
            // Change room
            currentRoom = room;
            currentRoom.setVisited(true);
            
            // Reset player position to center of new room
            double roomCenterX = currentRoom.getX() + currentRoom.getWidth() / 2 - player.getSize() / 2;
            double roomCenterY = currentRoom.getY() + currentRoom.getHeight() / 2 - player.getSize() / 2;
            player.setPosition(new Point2D(roomCenterX, roomCenterY));
            
            // Clear enemies and items from previous room
            enemies.clear();
            projectiles.clear();
            roomItems.clear();
            doors.clear();
            
            // Populate new room
            populateRoom(currentRoom);
            
            // Create doors for the new room
            createDoors();
            
            // Update minimap
            updateMinimap();
        });
        
        fadeIn.setOnFinished(e -> {
            // Remove the fade rectangle
            rootPane.getChildren().remove(fadeRect);
            roomTransitionInProgress = false;
            
            // Display room entrance message
            String roomTypeText = "";
            switch (currentRoom.getType()) {
                case COMBAT:
                    roomTypeText = "Combat Room";
                    break;
                case PUZZLE:
                    roomTypeText = "Puzzle Room";
                    break;
                case TREASURE:
                    roomTypeText = "Treasure Room";
                    break;
                case BOSS:
                    roomTypeText = "Boss Room";
                    break;
                case SPAWN:
                    roomTypeText = "Starting Room";
                    break;
            }
            
            // Show floating text for room type
            showFloatingText("Entered: " + roomTypeText, 
                new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4));
                
            // Initialize room-specific lighting
            updateLighting();
        });
        
        // Start the transition
        fadeOut.play();
    }
    
    private void handleDoorInteraction() {
        // Use the enhanced door interaction logic
        enhancedDoorInteraction();
    }
    
    private void checkRoomClearConditions() {
        // For combat rooms, check if all enemies are defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                if (!door.requiresKey()) {
                    door.setLocked(false);
                }
            }
            
            // Show message
            if (!roomCleared) {
                effectsManager.showFloatingText("Room cleared! Doors unlocked", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GREEN);
                roomCleared = true;
            }
        }
        
        // For boss rooms, check if boss is defeated
        if (currentRoom.getType() == DungeonRoom.RoomType.BOSS && enemies.isEmpty()) {
            // Unlock all doors
            for (Door door : doors) {
                door.setLocked(false);
            }
            
            // Show victory message
            if (!roomCleared) {
                effectsManager.showFloatingText("Boss defeated! Victory!", 
                    new Point2D(gameCanvas.getWidth() / 2, gameCanvas.getHeight() / 4), 
                    Color.GOLD);
                roomCleared = true;
            }
        }
    }
    
    private void render() {
        if (gameCanvas == null) {
            System.err.println("ERROR: Cannot render - gameCanvas is null");
            return;
        }
        
        GraphicsContext gc = gameCanvas.getGraphicsContext2D();
        
        // Clear the canvas
        gc.clearRect(0, 0, gameCanvas.getWidth(), gameCanvas.getHeight());
        
        // Draw the room background with appropriate lighting
        drawRoomBackground(gc);
        
        // Draw debug information if in debug mode
        if (isDebugMode) {
            gc.setFill(Color.WHITE);
            gc.setFont(Font.font("Verdana", FontWeight.BOLD, 12));
            
            gc.fillText("DEBUG MODE", 10, 20);
            gc.fillText("Current Room: " + currentRoom.getType() + " at (" + currentRoom.getX() + "," + currentRoom.getY() + ")", 10, 40);
            gc.fillText("Enemies: " + enemies.size(), 10, 60);
            gc.fillText("Doors: " + doors.size(), 10, 80);
            gc.fillText("Items: " + roomItems.size(), 10, 100);
            gc.fillText("Canvas Size: " + gameCanvas.getWidth() + "x" + gameCanvas.getHeight(), 10, 120);
        }
        
        // Draw the room doors
        if (doors.isEmpty()) {
            System.out.println("No doors to render");
        } else {
            System.out.println("Rendering " + doors.size() + " doors");
            for (Door door : doors) {
                // Draw door rectangle
                Color doorColor = door.isLocked() ? Color.RED : Color.GREEN;
                gc.setFill(doorColor);
            if (door.contains(playerPos)) {
                // Calculate distance to door center
                double doorCenterX = door.getX() + door.getWidth() / 2;
                double doorCenterY = door.getY() + door.getHeight() / 2;
                double distance = playerPos.distance(doorCenterX, doorCenterY);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestDoor = door;
                }
            }
        }
        
        // If no door found in direct contact, check if player is close to any door
        if (closestDoor == null) {
            double interactionRange = 20; // Maximum range to interact with doors
            
            for (Door door : doors) {
                double doorCenterX = door.getX() + door.getWidth() / 2;
                double doorCenterY = door.getY() + door.getHeight() / 2;
                double distance = playerPos.distance(doorCenterX, doorCenterY);
                
                if (distance < interactionRange && distance < closestDistance) {
                    closestDistance = distance;
                    closestDoor = door;
                }
            }
        }
        
        // If a door was found, interact with it
        if (closestDoor != null) {
            // Check if door is locked
            if (closestDoor.isLocked()) {
                if (closestDoor.requiresKey()) {
                    // Try to unlock door with key
                    if (closestDoor.unlock(player.getInventory())) {
                        // Door unlocked - show effects
                        Point2D doorCenter = new Point2D(
                            closestDoor.getX() + closestDoor.getWidth() / 2,
                            closestDoor.getY() + closestDoor.getHeight() / 2
                        );
                        
                        // Show unlock text
                        effectsManager.showFloatingText("Door Unlocked!", 
                            new Point2D(doorCenter.getX(), doorCenter.getY() - 30),
                            Color.YELLOW, 24);
                        
                        // Add particles for unlocking effect
                        for (int i = 0; i < 20; i++) {
                            double angle = Math.random() * Math.PI * 2;
                            double speed = 0.5 + Math.random() * 1.5;
                            double particleX = doorCenter.getX() + Math.cos(angle) * 10;
                            double particleY = doorCenter.getY() + Math.sin(angle) * 10;
                            
                            Color particleColor = Color.YELLOW;
                            if (Math.random() < 0.3) {
                                particleColor = Color.GOLD;
                            } else if (Math.random() < 0.5) {
                                particleColor = Color.WHITE;
                            }
                            
                            effectsManager.addParticle(
                                new Point2D(particleX, particleY),
                                particleColor,
                                speed
                            );
                        }
                        
                        // Play sound effect (placeholder)
                        System.out.println("SOUND: Door unlocked");
                    } else {
                        // Show message that key is required
                        effectsManager.showFloatingText("Key Required!", 
                            new Point2D(closestDoor.getX() + closestDoor.getWidth() / 2, 
                                       closestDoor.getY() - 20),
                            Color.RED, 20);
                        
                        // Show hint about finding keys
                        if (Math.random() < 0.3) { // Only show hint sometimes
                            effectsManager.showFloatingText("Keys can be found in puzzle rooms", 
                                new Point2D(closestDoor.getX() + closestDoor.getWidth() / 2, 
                                           closestDoor.getY() - 40),
                                Color.LIGHTGRAY, 16);
                        }
                    }
                } else {
                    // Door is locked because the room is not cleared
                    String message;
                    Color messageColor = Color.RED;
                    
                    // Provide more specific feedback
                    if (currentRoom.getType() == DungeonRoom.RoomType.COMBAT || 
                        currentRoom.getType() == DungeonRoom.RoomType.BOSS) {
                        
                        message = "Defeat all enemies to unlock!";
                        
                        // Show enemy count if less than 5 remaining
                        if (enemies.size() < 5) {
                            message += " (" + enemies.size() + " left)";
                        }
                    } else if (currentRoom.getType() == DungeonRoom.RoomType.PUZZLE) {
                        message = "Solve the puzzle to unlock!";
                    } else {
                        message = "Clear the room first!";
                    }
                    
                    // Show message about room not being cleared
                    effectsManager.showFloatingText(message, 
                        new Point2D(closestDoor.getX() + closestDoor.getWidth() / 2, 
                                   closestDoor.getY() - 20),
                        messageColor, 20);
                }
            } else {
                // Door is unlocked, transition to connected room
                DungeonRoom connectedRoom = closestDoor.getConnectedRoom();
                
                if (connectedRoom != null) {
                    // Show room transition effect
                    Point2D doorCenter = new Point2D(
                        closestDoor.getX() + closestDoor.getWidth() / 2,
                        closestDoor.getY() + closestDoor.getHeight() / 2
                    );
                    
                    // Add particles for transition effect
                    for (int i = 0; i < 10; i++) {
                        double angle = Math.random() * Math.PI * 2;
                        double speed = 0.5 + Math.random() * 1.0;
                        
                        effectsManager.addParticle(
                            new Point2D(doorCenter.getX(), doorCenter.getY()),
                            Color.WHITE,
                            speed
                        );
                    }
                    
                    // Transition to new room
                    Point2D entryPosition = getEntryPosition(closestDoor);
                    transitionToRoom(connectedRoom, entryPosition);
                    
                    // Update player stats
                    if (!connectedRoom.isVisited()) {
                        // First time visiting this room - increment rooms explored count
                        int currentRooms = player.getRoomsExplored();
                        // Note: We don't call setRoomsExplored as it doesn't exist
                        System.out.println("Player explored a new room! Total: " + (currentRooms + 1));
                    }
                } else {
                    // Connected room is null (shouldn't happen)
                    System.err.println("ERROR: Connected room is null for door at " + 
                                      closestDoor.getX() + "," + closestDoor.getY());
                }
            }
        }
    }
}
